{"path": "scan_folder.py", "extension": ".py", "size_bytes": 8387, "modified_time": "2025-11-25 19:50:02", "sha256": "febedb3d2eba589bdb58bc1e980cad6e415f1a16903eaa9c34f9e870397fbffd", "is_text": true, "encoding": "utf-8", "truncated": false, "content": "# scan_folder.py\n# -*- coding: utf-8 -*-\nimport os, sys, csv, time, json, base64, hashlib\nfrom collections import defaultdict\n\nDEFAULT_TARGET = r\"/home/tel/tel2025\"\n\n# ç•¥éçš„è³‡æ–™å¤¾\nSKIP_DIRS = {\n    \".git\",\"__pycache__\",\"node_modules\",\".venv\",\"venv\",\"env\",\n    \"build\",\"dist\",\".idea\",\".vscode\",\".pytest_cache\",\".mypy_cache\",\".cache\"\n}\n\n# åªæŠŠ .py ç•¶ä½œæ–‡å­—æª”è™•ç†\nTEXT_EXTS = {\n    \".py\",\n}\n\n# å…§å®¹è¼¸å‡ºæ§åˆ¶\nMAX_TEXT_BYTES = 512 * 1024      # å–®ä¸€æ–‡å­—æª”æœ€å¤šè®€ 512 KB å…§å®¹\nMAX_BINARY_BYTES = 0             # äºŒé€²ä½æª”æ˜¯å¦è¼¸å‡º base64ï¼ˆ0=ä¸è¼¸å‡ºï¼Œåªè¨˜éŒ„é›œæ¹Šèˆ‡ä¸­ç¹¼è³‡æ–™ï¼‰\nENCODING = \"utf-8\"               # æ–‡å­—è®€å–ç·¨ç¢¼ï¼ˆå¤±æ•—å‰‡ç”¨ errors='replace'ï¼‰\n\ndef is_probably_binary(path, ext) -> bool:\n    if ext.lower() in TEXT_EXTS:\n        return False\n    try:\n        with open(path, \"rb\") as f:\n            head = f.read(4096)\n        # æœ‰ NUL æˆ–å¤ªå¤šéå¯åˆ—å°æ§åˆ¶å­— â†’ è¦–ç‚ºäºŒé€²ä½\n        if b\"\\x00\" in head:\n            return True\n        nontext = sum(1 for b in head if b < 9 or (13 < b < 32) or b == 127)\n        return nontext / max(1, len(head)) > 0.30\n    except Exception:\n        return True\n\ndef human_size(n: int) -> str:\n    units = [\"B\",\"KB\",\"MB\",\"GB\",\"TB\"]\n    i, f = 0, float(n)\n    while f >= 1024 and i < len(units)-1:\n        f /= 1024; i += 1\n    return f\"{f:.2f} {units[i]}\"\n\ndef sha256_file(path: str) -> str:\n    h = hashlib.sha256()\n    with open(path, \"rb\") as f:\n        for chunk in iter(lambda: f.read(1024 * 1024), b\"\"):\n            h.update(chunk)\n    return h.hexdigest()\n\ndef gen_tree(root: str, skip_dirs=SKIP_DIRS, max_files_per_dir=200) -> str:\n    lines = []\n    root = os.path.abspath(root)\n    for current_root, dirs, files in os.walk(root):\n        rel = os.path.relpath(current_root, root)\n        depth = 0 if rel == \".\" else rel.count(os.sep) + 1\n        indent = \"    \" * depth\n        lines.append((os.path.basename(root) if rel == \".\" else f\"{'    '*(depth-1)}â””â”€ {os.path.basename(current_root)}\"))\n        dirs[:] = [d for d in dirs if d not in skip_dirs]\n        shown = 0\n        for name in sorted(files):\n            if shown >= max_files_per_dir:\n                lines.append(f\"{indent}â””â”€ ... ({len(files)-shown} more files)\")\n                break\n            lines.append(f\"{indent}â””â”€ {name}\")\n            shown += 1\n    return \"\\n\".join(lines)\n\ndef main():\n    target = sys.argv[1] if len(sys.argv) >= 2 else DEFAULT_TARGET\n    target = os.path.abspath(os.path.expanduser(target))\n    if not os.path.isdir(target):\n        print(f\"âŒ æ‰¾ä¸åˆ°è³‡æ–™å¤¾ï¼š{target}\")\n        sys.exit(1)\n\n    out_csv  = os.path.join(target, \"files_report.csv\")\n    out_tree = os.path.join(target, \"files_tree.txt\")\n    out_jsonl = os.path.join(target, \"files_content.jsonl\")\n    out_alltxt = os.path.join(target, \"ALL_TEXTS.txt\")\n\n    by_ext_count = defaultdict(int)\n    by_ext_size = defaultdict(int)\n    total_files = total_bytes = 0\n\n    # å…ˆå¯« CSVï¼ˆä¸­ç¹¼è³‡æ–™ï¼‰\n    with open(out_csv, \"w\", newline=\"\", encoding=\"utf-8-sig\") as fcsv, \\\n         open(out_jsonl, \"w\", encoding=\"utf-8\") as fjsonl, \\\n         open(out_alltxt, \"w\", encoding=\"utf-8\", errors=\"replace\") as falltxt:\n\n        writer = csv.writer(fcsv)\n        writer.writerow([\n            \"relative_path\", \"extension\", \"size_bytes\", \"size_human\",\n            \"modified_time\", \"is_text\", \"line_count\", \"sha256\"\n        ])\n\n        for root_dir, dirs, files in os.walk(target):\n            dirs[:] = [d for d in dirs if d not in SKIP_DIRS]\n            for fname in files:\n                ext = os.path.splitext(fname)[1].lower()\n\n                # åªè™•ç† .py æª”ï¼Œå…¶å®ƒå…¨éƒ¨ç•¥é\n                if ext != \".py\":\n                    continue\n\n                fpath = os.path.join(root_dir, fname)\n                rel = os.path.relpath(fpath, target)\n\n                try:\n                    stat = os.stat(fpath)\n                except OSError:\n                    continue\n\n                size = stat.st_size\n                mtime = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(stat.st_mtime))\n                is_bin = is_probably_binary(fpath, ext)\n                sha256 = sha256_file(fpath)\n\n                line_count = \"\"\n                text_preview = \"\"\n                encoding_used = None\n\n                if not is_bin:\n                    # è®€éƒ¨åˆ†æ–‡å­—å…§å®¹ï¼ˆé™åˆ¶å¤§å°ï¼‰\n                    try:\n                        with open(fpath, \"r\", encoding=ENCODING, errors=\"replace\") as fr:\n                            content = fr.read(min(MAX_TEXT_BYTES, size))\n                            encoding_used = ENCODING\n                            text_preview = content\n                            line_count = content.count(\"\\n\") + (1 if content and not content.endswith(\"\\n\") else 0)\n                    except Exception:\n                        pass\n\n                    # å¯«å…¥ ALL_TEXTS åŒ¯ç¸½\n                    falltxt.write(\"\\n\" + \"=\"*80 + \"\\n\")\n                    falltxt.write(f\"FILE: {rel}\\n\")\n                    falltxt.write(\"=\"*80 + \"\\n\")\n                    if text_preview:\n                        falltxt.write(text_preview)\n                        if size > MAX_TEXT_BYTES:\n                            falltxt.write(\"\\n[... TRUNCATED ...]\\n\")\n                    else:\n                        falltxt.write(\"[[EMPTY OR UNREADABLE TEXT]]\\n\")\n\n                    # JSONLï¼šæ–‡å­—\n                    json.dump({\n                        \"path\": rel,\n                        \"extension\": ext or \"(noext)\",\n                        \"size_bytes\": size,\n                        \"modified_time\": mtime,\n                        \"sha256\": sha256,\n                        \"is_text\": True,\n                        \"encoding\": encoding_used or \"utf-8\",\n                        \"truncated\": bool(size > MAX_TEXT_BYTES),\n                        \"content\": text_preview\n                    }, fjsonl, ensure_ascii=False)\n                    fjsonl.write(\"\\n\")\n\n                else:\n                    # JSONLï¼šäºŒé€²ä½ï¼ˆé è¨­ä¸å«å…§å®¹ï¼Œåªè¨˜é›œæ¹Šèˆ‡ä¸­ç¹¼è³‡æ–™ï¼›éœ€è¦å¯æ”¹ MAX_BINARY_BYTESï¼‰\n                    b64 = None\n                    if MAX_BINARY_BYTES > 0:\n                        try:\n                            with open(fpath, \"rb\") as fb:\n                                raw = fb.read(min(MAX_BINARY_BYTES, size))\n                            b64 = base64.b64encode(raw).decode(\"ascii\")\n                        except Exception:\n                            b64 = None\n\n                    json.dump({\n                        \"path\": rel,\n                        \"extension\": ext or \"(noext)\",\n                        \"size_bytes\": size,\n                        \"modified_time\": mtime,\n                        \"sha256\": sha256,\n                        \"is_text\": False,\n                        \"base64_bytes\": b64,\n                        \"truncated\": bool(size > MAX_BINARY_BYTES) if MAX_BINARY_BYTES > 0 else None\n                    }, fjsonl)\n                    fjsonl.write(\"\\n\")\n\n                # CSVï¼ˆä¸­ç¹¼è³‡æ–™ä¸€è¦½ï¼‰\n                writer.writerow([\n                    rel, ext or \"(noext)\", size, human_size(size), mtime,\n                    int(not is_bin), line_count, sha256\n                ])\n\n                by_ext_count[ext] += 1\n                by_ext_size[ext] += size\n                total_files += 1\n                total_bytes += size\n\n    # ç”¢ç”Ÿæ¨¹ç‹€ï¼ˆä»åˆ—å‡ºå…¨éƒ¨æª”æ¡ˆçµæ§‹ï¼‰\n    with open(out_tree, \"w\", encoding=\"utf-8\") as ftree:\n        ftree.write(gen_tree(target))\n\n    # æ‘˜è¦\n    print(\"ğŸ“ æƒæå®Œæˆï¼š\", target)\n    print(f\"   æª”æ¡ˆç¸½æ•¸ï¼š{total_files}\")\n    print(f\"   ç¸½å¤§å°  ï¼š{human_size(total_bytes)}\")\n    print(\"   ä¾å‰¯æª”åçµ±è¨ˆï¼ˆå‰ 15 åï¼‰ï¼š\")\n    top = sorted(by_ext_count.items(), key=lambda kv: by_ext_size[kv[0]], reverse=True)[:15]\n    for ext, cnt in top:\n        print(f\"   {ext or '(noext)':>8}  {cnt:>6} æª”  {human_size(by_ext_size[ext]):>10}\")\n\n    print(f\"\\nâœ… å·²è¼¸å‡ºï¼š\\n  - {out_csv}\\n  - {out_tree}\\n  - {out_jsonl}\\n  - {out_alltxt}\")\n    print(\"\\nâš™ï¸ åƒæ•¸ï¼šMAX_TEXT_BYTES={}, MAX_BINARY_BYTES={}ï¼ˆå¯åœ¨æª”é ­èª¿æ•´ï¼‰\".format(MAX_TEXT_BYTES, MAX_BINARY_BYTES))\n    print(\"ğŸ’¡ JSONL å¯è¢« jq / pandas / BigQuery / Elasticsearch ç­‰ç›´æ¥ä½¿ç”¨ï¼›ALL_TEXTS.txt æ–¹ä¾¿äººå·¥æª¢è¦–ã€‚\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"path": "pi_remote_server.py", "extension": ".py", "size_bytes": 7295, "modified_time": "2025-11-17 22:49:16", "sha256": "32e5a964dabadde2cdfaef40e873f3c532a8f9bcf2fedc17b6afeb48b07ace15", "is_text": true, "encoding": "utf-8", "truncated": false, "content": "# pi_remote_server.py\n# åŠŸèƒ½ï¼š\n#   - å•Ÿå‹• mega1_controller.serial_worker æ§åˆ¶ åº•ç›¤+å°„æ‰‹ (æ§åˆ¶æ¿1)\n#   - ä½¿ç”¨ aim.SerialLink æ§åˆ¶ ç„æº–å…©è»¸ (æ§åˆ¶æ¿2)\n#   - é–‹ TCP ä¼ºæœå™¨ï¼Œæ¥å—ä¾†è‡ª PC çš„æ–‡å­—æŒ‡ä»¤\n\nimport socket\nimport threading\nimport multiprocessing as mp\nimport time\n\nfrom mega1_controller import serial_worker, MODE_CHASSIS, MODE_SHOOTER, DEFAULT_BAUD\nfrom aim import SerialLink, BAUD as AIM_BAUD\n\n# === è«‹ä¾å¯¦éš›æƒ…æ³ä¿®æ”¹é€™å…©å€‹åºåˆ—åŸ åç¨± ===\nMEGA1_PORT = \"/dev/ttyUSB0\"   # æ§åº•ç›¤+å°„æ‰‹çš„é‚£å¡Šæ§åˆ¶æ¿\nAIM_PORT   = \"/dev/ttyACM0\"   # æ§ç ²å°ä»°è§’/æ–¹å‘çš„é‚£å¡Šæ¿å­\n\nTCP_HOST = \"0.0.0.0\"\nTCP_PORT = 5000\n\ndef start_mega_worker():\n    \"\"\"å•Ÿå‹• mega1_controller è£¡çš„ serial_worker å­ç¨‹åºï¼Œå›å‚³ (cmd_q, log_q, process)\"\"\"\n    cmd_q = mp.Queue(maxsize=500)\n    log_q = mp.Queue(maxsize=1000)\n\n    p = mp.Process(target=serial_worker, args=(cmd_q, log_q), daemon=True)\n    p.start()\n\n    # é–‹å•Ÿ MEGA1 åºåˆ—åŸ \n    cmd_q.put({\n        \"type\": \"open\",\n        \"port\": MEGA1_PORT,\n        \"baud\": DEFAULT_BAUD,\n    })\n    # åŒæ­¥é€è¨Šé–“éš”ï¼Œå¯è¦–éœ€è¦èª¿æ•´\n    cmd_q.put({\n        \"type\": \"set_interval\",\n        \"interval\": 0.08,\n    })\n\n    return cmd_q, log_q, p\n\ndef start_aim_link():\n    \"\"\"å»ºç«‹ç¬¬äºŒå¡Šæ¿ (AIM) çš„ SerialLink\"\"\"\n    link = SerialLink()\n    link.open(AIM_PORT, AIM_BAUD)\n    return link\n\ndef handle_client(conn, addr, cmd_q, aim_link):\n    print(f\"[CLIENT] {addr} é€£ç·šé€²ä¾†\")\n    mode_current = MODE_CHASSIS\n\n    def set_mode(new_mode, force=False):\n        nonlocal mode_current\n        if not force and mode_current == new_mode:\n            return\n        mode_current = new_mode\n        cmd_q.put({\"type\": \"set_mode\", \"mode\": new_mode})\n\n    f = conn.makefile(\"r\")  # è®“æˆ‘å€‘å¯ä»¥ç”¨ for line in f è®€\n    try:\n        for line in f:\n            line = line.strip()\n            if not line:\n                continue\n\n            print(f\"[RECV] {addr}: {line}\")\n            parts = line.split()\n            cmd = parts[0].upper()\n\n            try:\n                if cmd == \"CHASSIS\":\n                    # CHASSIS vx vy wz\n                    if len(parts) != 4:\n                        conn.sendall(b\"ERR CHASSIS usage: CHASSIS vx vy wz\\n\")\n                        continue\n                    vx = float(parts[1])\n                    vy = float(parts[2])\n                    wz = float(parts[3])\n                    set_mode(MODE_CHASSIS)\n                    cmd_q.put({\"type\": \"velocity\", \"vx\": vx, \"vy\": vy, \"wz\": wz})\n                    conn.sendall(b\"OK CHASSIS\\n\")\n\n                elif cmd == \"MODE\":\n                    # MODE CHASSIS / MODE SHOOTER\n                    if len(parts) != 2:\n                        conn.sendall(b\"ERR MODE usage: MODE CHASSIS|SHOOTER\\n\")\n                        continue\n                    tgt = parts[1].upper()\n                    if tgt not in (MODE_CHASSIS, MODE_SHOOTER):\n                        conn.sendall(b\"ERR MODE must be CHASSIS or SHOOTER\\n\")\n                        continue\n                    set_mode(tgt, force=True)\n                    conn.sendall(b\"OK MODE\\n\")\n\n                elif cmd == \"STEP\":\n                    # STEP F / STEP R / STEP S\n                    if len(parts) != 2:\n                        conn.sendall(b\"ERR STEP usage: STEP F|R|S\\n\")\n                        continue\n                    sub = parts[1].upper()\n                    if sub not in (\"F\", \"R\", \"S\"):\n                        conn.sendall(b\"ERR STEP must be F/R/S\\n\")\n                        continue\n                    set_mode(MODE_SHOOTER)\n                    cmd_q.put({\"type\": \"raw\", \"text\": sub})\n                    conn.sendall(b\"OK STEP\\n\")\n\n                elif cmd == \"SERVO\":\n                    # SERVO S1 / SERVO S2 / SERVO S3\n                    if len(parts) != 2:\n                        conn.sendall(b\"ERR SERVO usage: SERVO S1|S2|S3\\n\")\n                        continue\n                    sub = parts[1].upper()\n                    if sub not in (\"S1\", \"S2\", \"S3\"):\n                        conn.sendall(b\"ERR SERVO must be S1/S2/S3\\n\")\n                        continue\n                    set_mode(MODE_SHOOTER)\n                    cmd_q.put({\"type\": \"raw\", \"text\": sub})\n                    conn.sendall(b\"OK SERVO\\n\")\n\n                elif cmd == \"NEO\":\n                    # NEO -100..100\n                    if len(parts) != 2:\n                        conn.sendall(b\"ERR NEO usage: NEO value(-100..100)\\n\")\n                        continue\n                    val = int(parts[1])\n                    if val < -100: val = -100\n                    if val > 100: val = 100\n                    set_mode(MODE_SHOOTER)\n                    cmd_q.put({\"type\": \"raw\", \"text\": str(val)})\n                    conn.sendall(b\"OK NEO\\n\")\n\n                elif cmd == \"AIM\":\n                    # AIM axis angle\n                    if len(parts) != 3:\n                        conn.sendall(b\"ERR AIM usage: AIM axis angle\\n\")\n                        continue\n                    axis = int(parts[1])\n                    angle = float(parts[2])\n                    if axis not in (1, 2):\n                        conn.sendall(b\"ERR AIM axis must be 1 or 2\\n\")\n                        continue\n                    aim_link.send_angle(axis, angle)\n                    conn.sendall(b\"OK AIM\\n\")\n\n                elif cmd == \"RAW\":\n                    # RAW å¾Œé¢æ•´ä¸²éƒ½ä¸Ÿåˆ° MEGA (chassis/shooter é‚£å¡Š)\n                    if len(parts) < 2:\n                        conn.sendall(b\"ERR RAW usage: RAW your_command\\n\")\n                        continue\n                    txt = line[4:].strip()  # å»æ‰ \"RAW \"\n                    cmd_q.put({\"type\": \"raw\", \"text\": txt})\n                    conn.sendall(b\"OK RAW\\n\")\n\n                elif cmd == \"STATUS\":\n                    # ç°¡å–®å›æ‡‰ä¸€ä¸‹\n                    conn.sendall(f\"MODE={mode_current}\\n\".encode(\"utf-8\"))\n\n                elif cmd == \"QUIT\":\n                    conn.sendall(b\"BYE\\n\")\n                    break\n\n                else:\n                    conn.sendall(b\"ERR unknown command\\n\")\n\n            except Exception as e:\n                err = f\"ERR exception: {e}\\n\"\n                conn.sendall(err.encode(\"utf-8\"))\n\n    finally:\n        print(f\"[CLIENT] {addr} é›¢ç·š\")\n        conn.close()\n\ndef main():\n    mp.freeze_support()\n\n    print(\"[INFO] å•Ÿå‹• MEGA1 worker ...\")\n    cmd_q, log_q, worker = start_mega_worker()\n\n    print(\"[INFO] å•Ÿå‹• AIM SerialLink ...\")\n    aim_link = start_aim_link()\n\n    print(f\"[INFO] å•Ÿå‹• TCP ä¼ºæœå™¨ {TCP_HOST}:{TCP_PORT}\")\n    srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    srv.bind((TCP_HOST, TCP_PORT))\n    srv.listen(5)\n\n    try:\n        while True:\n            conn, addr = srv.accept()\n            th = threading.Thread(\n                target=handle_client,\n                args=(conn, addr, cmd_q, aim_link),\n                daemon=True\n            )\n            th.start()\n    finally:\n        print(\"[INFO] é—œé–‰ä¼ºæœå™¨\")\n        srv.close()\n        cmd_q.put({\"type\": \"quit\"})\n        try:\n            worker.join(timeout=1.0)\n        except:\n            pass\n        aim_link.close()\n\nif __name__ == \"__main__\":\n    main()\n"}
{"path": "aim.py", "extension": ".py", "size_bytes": 7170, "modified_time": "2025-11-17 17:09:13", "sha256": "a74eecf35db154b78d7a323e5421e390cb855468991fbbe51b48cf7f810481cf", "is_text": true, "encoding": "utf-8", "truncated": false, "content": "# aim.py\n# æ–¹å‘éµï¼š\n#   â† / â†’  : M1 (- / + 1Â°)\n#   â†‘ / â†“  : M2 (+ / - 1Â°)\n# å‚³é€æ ¼å¼ï¼š \"1,<angle>\\n\" æˆ– \"2,<angle>\\n\"\n# åŠŸèƒ½é‡é»ï¼šå¯å¾ä¸‹æ‹‰é¸å–®é¸å– COMï¼Œé€£ç·š/æ–·ç·šã€é‡æ–°æ•´ç†å¯ç”¨åŸ \n\nimport time\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nimport serial\nimport serial.tools.list_ports\n\nBAUD     = 115200\nSTEP_DEG = 1.0  # æ¯æ¬¡æŒ‰éµè®ŠåŒ–è§’åº¦\n\nclass SerialLink:\n    def __init__(self):\n        self.ser = None\n\n    def open(self, port: str, baud: int = BAUD):\n        self.close()\n        try:\n            self.ser = serial.Serial(port, baudrate=baud, timeout=0.1)\n        except Exception as e:\n            self.ser = None\n            raise e\n        # Arduino é€£ä¸Šæœƒ resetï¼Œçµ¦é»æ™‚é–“\n        time.sleep(2.0)\n\n    def is_open(self):\n        return self.ser is not None and self.ser.is_open\n\n    def send_angle(self, axis_id: int, angle: float):\n        if not self.is_open():\n            return\n        msg = f\"{axis_id},{angle:.3f}\\n\"\n        try:\n            self.ser.write(msg.encode(\"utf-8\"))\n        except Exception as e:\n            # é€å¤±æ•—å°±æ–·ç·šï¼Œé¿å…ä¹‹å¾Œä¸€ç›´å ±éŒ¯\n            try:\n                self.close()\n            finally:\n                raise e\n\n    def close(self):\n        if self.ser:\n            try:\n                if self.ser.is_open:\n                    self.ser.close()\n            finally:\n                self.ser = None\n\ndef list_serial_ports():\n    # å›å‚³ [(é¡¯ç¤ºå­—ä¸², è£ç½®å­—ä¸²), ...]\n    items = []\n    for p in serial.tools.list_ports.comports():\n        display = f\"{p.device} â€” {p.description}\"\n        items.append((display, p.device))\n    # è‹¥æ²’æ‰¾åˆ°ä»»ä½•è£ç½®ï¼Œä»å…è¨±æ‰‹å‹•è¼¸å…¥\n    return items\n\nclass ControllerApp:\n    def __init__(self, master):\n        self.master = master\n        self.master.title(\"Arrow Controller (é¸æ“‡ COMï¼šé€£ç·šå¾Œç”¨æ–¹å‘éµ)\")\n        self.master.geometry(\"420x180\")\n\n        self.link = SerialLink()\n        self.m1_angle = 0.0\n        self.m2_angle = 0.0\n\n        # ===== ä¸Šæ–¹ï¼šCOM é¸æ“‡åˆ— =====\n        top = ttk.Frame(master, padding=8)\n        top.pack(fill=\"x\")\n\n        ttk.Label(top, text=\"é€£æ¥åŸ ï¼š\").pack(side=\"left\")\n        self.port_var = tk.StringVar()\n        self.port_combo = ttk.Combobox(top, textvariable=self.port_var, width=35)\n        self.port_combo.pack(side=\"left\", padx=6)\n        self.port_combo.configure(state=\"normal\")  # å¯æ‰‹å‹•è¼¸å…¥\n\n        self.refresh_btn = ttk.Button(top, text=\"é‡æ–°æ•´ç†\", command=self.refresh_ports)\n        self.refresh_btn.pack(side=\"left\", padx=4)\n\n        self.connect_btn = ttk.Button(top, text=\"é€£ç·š\", command=self.toggle_connect)\n        self.connect_btn.pack(side=\"left\", padx=4)\n\n        # ===== ä¸­æ®µï¼šè§’åº¦é¡¯ç¤º =====\n        mid = ttk.Frame(master, padding=8)\n        mid.pack(fill=\"x\")\n        self.lbl1 = ttk.Label(mid, text=f\"M1: {self.m1_angle:.3f}Â°\", font=(\"Consolas\", 16))\n        self.lbl2 = ttk.Label(mid, text=f\"M2: {self.m2_angle:.3f}Â°\", font=(\"Consolas\", 16))\n        self.lbl1.pack(pady=2)\n        self.lbl2.pack(pady=2)\n\n        # ===== åº•éƒ¨ï¼šæç¤º/ç‹€æ…‹ =====\n        bot = ttk.Frame(master, padding=8)\n        bot.pack(fill=\"x\")\n        self.hint = ttk.Label(bot, text=\"â†/â†’ æ§ M1 | â†‘/â†“ æ§ M2 | æ¯æ¬¡ Â±1Â°\", foreground=\"#444\")\n        self.hint.pack(side=\"left\")\n        self.status_var = tk.StringVar(value=\"æœªé€£ç·š\")\n        self.status = ttk.Label(bot, textvariable=self.status_var, foreground=\"#A00\")\n        self.status.pack(side=\"right\")\n\n        # ç¶å®šæ–¹å‘éµï¼ˆåªåœ¨å·²é€£ç·šæ™‚å‹•ä½œï¼‰\n        master.bind_all(\"<Left>\",  self.on_left)\n        master.bind_all(\"<Right>\", self.on_right)\n        master.bind_all(\"<Up>\",    self.on_up)\n        master.bind_all(\"<Down>\",  self.on_down)\n\n        master.protocol(\"WM_DELETE_WINDOW\", self.on_close)\n\n        # åˆå§‹åŒ–å¯ç”¨åŸ \n        self.refresh_ports()\n        # è‡ªå‹•é¸ç¬¬ä¸€å€‹ï¼ˆè‹¥æœ‰ï¼‰\n        if self.port_combo[\"values\"]:\n            self.port_combo.current(0)\n\n        # è®“è¦–çª—å–å¾—ç„¦é»ï¼Œæ–¹å‘éµæ‰æœƒé€²ä¾†\n        master.after(150, lambda: master.focus_force())\n\n    def refresh_ports(self):\n        items = list_serial_ports()\n        display_list = [d for d, _ in items]\n        self.port_map = {d: dev for d, dev in items}\n        self.port_combo[\"values\"] = display_list\n        if not display_list:\n            self.status_var.set(\"æ‰¾ä¸åˆ°å¯ç”¨é€£æ¥åŸ ï¼Œå¯æ‰‹å‹•è¼¸å…¥ï¼ˆå¦‚ COM7ï¼‰\")\n        else:\n            self.status_var.set(\"è«‹é¸æ“‡é€£æ¥åŸ ä¸¦é»ã€é€£ç·šã€\")\n\n    def toggle_connect(self):\n        if self.link.is_open():\n            self.link.close()\n            self.connect_btn.config(text=\"é€£ç·š\")\n            self.status_var.set(\"å·²æ–·ç·š\")\n            self.status.config(foreground=\"#A00\")\n            return\n\n        # é€£ç·š\n        sel = self.port_var.get().strip()\n        if not sel:\n            messagebox.showwarning(\"æç¤º\", \"è«‹å…ˆé¸æ“‡æˆ–è¼¸å…¥é€£æ¥åŸ ï¼ˆä¾‹å¦‚ COM7ï¼‰\")\n            return\n\n        # è‹¥é¸çš„æ˜¯ä¸‹æ‹‰é¡¯ç¤ºå­—ä¸²ï¼Œè½‰å›å¯¦éš›è£ç½®åç¨±\n        port = self.port_map.get(sel, sel)  # è‹¥æ²’å°æ‡‰ï¼Œè¦–ç‚ºä½¿ç”¨è€…æ‰‹å‹•è¼¸å…¥\n        try:\n            self.link.open(port, BAUD)\n        except Exception as e:\n            messagebox.showerror(\"é€£ç·šå¤±æ•—\", f\"ç„¡æ³•é–‹å•Ÿ {port}\\n{e}\")\n            self.status_var.set(\"é€£ç·šå¤±æ•—\")\n            self.status.config(foreground=\"#A00\")\n            return\n\n        self.connect_btn.config(text=\"æ–·ç·š\")\n        self.status_var.set(f\"å·²é€£ç·šï¼š{port} @ {BAUD}\")\n        self.status.config(foreground=\"#0A0\")\n\n    # ===== éµç›¤äº‹ä»¶ =====\n    def on_left(self, _):\n        if not self.link.is_open(): return\n        self.m1_angle -= STEP_DEG\n        self.send_and_update(1, self.m1_angle)\n\n    def on_right(self, _):\n        if not self.link.is_open(): return\n        self.m1_angle += STEP_DEG\n        self.send_and_update(1, self.m1_angle)\n\n    def on_up(self, _):\n        if not self.link.is_open(): return\n        self.m2_angle += STEP_DEG\n        self.send_and_update(2, self.m2_angle)\n\n    def on_down(self, _):\n        if not self.link.is_open(): return\n        self.m2_angle -= STEP_DEG\n        self.send_and_update(2, self.m2_angle)\n\n    def send_and_update(self, axis_id: int, angle: float):\n        try:\n            self.link.send_angle(axis_id, angle)\n        except Exception as e:\n            messagebox.showerror(\"å‚³é€å¤±æ•—\", f\"åºåˆ—å‚³é€å¤±æ•—ï¼Œå·²è‡ªå‹•æ–·ç·šã€‚\\n{e}\")\n            self.connect_btn.config(text=\"é€£ç·š\")\n            self.status_var.set(\"å‚³é€å¤±æ•—ï¼Œå·²æ–·ç·š\")\n            self.status.config(foreground=\"#A00\")\n            return\n\n        if axis_id == 1:\n            self.lbl1.config(text=f\"M1: {self.m1_angle:.3f}Â°\")\n        else:\n            self.lbl2.config(text=f\"M2: {self.m2_angle:.3f}Â°\")\n\n    def on_close(self):\n        try:\n            self.link.close()\n        finally:\n            self.master.destroy()\n\ndef main():\n    root = tk.Tk()\n    # Windows ç”¨è€…ï¼šè‹¥å­—é«”ç¼ºï¼Œæ”¹æˆ (\"Consolas\", 16) ä»¥å¤–çš„ç­‰å¯¬å­—é«”äº¦å¯\n    app = ControllerApp(root)\n    root.mainloop()\n\nif __name__ == \"__main__\":\n    main()\n"}
{"path": "mega1_controller.py", "extension": ".py", "size_bytes": 19512, "modified_time": "2025-11-17 17:09:12", "sha256": "f5ff57ecc8df23701d0ff49cfdd9d9fab59dcb22c314a762bfbb9c9ddc734123", "is_text": true, "encoding": "utf-8", "truncated": false, "content": "# mega1_controller.py\n# Mecanum Serial é™æ§å™¨ï¼ˆå¤šé€²ç¨‹ï¼›GUI ä¸é˜»å¡ï¼›è‡ªå‹•åˆ‡ MODEï¼›ç©©å®šç‰ˆï¼‰\n# Run: python mega1_controller.py\n# pip install pyserial\n\nimport time, sys, queue\nimport tkinter as tk\nfrom tkinter import ttk, scrolledtext\nimport serial, serial.tools.list_ports\n\nimport multiprocessing as mp\n\n# ====== åŸºæœ¬è¨­å®š ======\nDEFAULT_BAUD   = 115200\nSEND_INTERVAL  = 0.08   # å…ˆç”¨ 12.5Hzï¼Œç©©äº†å¯æ”¹å› 0.05\nMODE_CHASSIS   = \"CHASSIS\"\nMODE_SHOOTER   = \"SHOOTER\"\n\n# ====== ä¸²åˆ—å­ç¨‹åº ======\ndef serial_worker(cmd_q: mp.Queue, log_q: mp.Queue):\n    ser = None\n    port = None; baud = None\n    mode = MODE_CHASSIS\n    vx = vy = wz = 0.0\n    interval = SEND_INTERVAL\n    pause_until = 0.0\n    next_tx = 0.0\n    buf = b\"\"\n\n    def log(txt): \n        try: log_q.put_nowait(txt)\n        except queue.Full: pass\n\n    def open_port(p, b):\n        nonlocal ser, port, baud\n        try:\n            if ser: \n                try: ser.close()\n                except: pass\n            ser = serial.Serial(p, b, timeout=0, write_timeout=0)  # éé˜»å¡\n            port, baud = p, b\n            time.sleep(1.5)           # ç­‰ Arduino è‡ªå‹•é‡ç½®\n            try: ser.reset_input_buffer()\n            except: pass\n            log(f\"[OPEN] {p} @ {b}\")\n            # åŒæ­¥ç›®å‰æ¨¡å¼\n            send_line(f\"MODE {mode}\")\n        except Exception as e:\n            ser = None; log(f\"[ERROR] open failed: {e}\")\n\n    def close_port():\n        nonlocal ser\n        if ser:\n            try: ser.close()\n            except: pass\n            ser = None\n            log(\"[CLOSED] serial\")\n\n    def send_line(s):\n        nonlocal pause_until\n        if not ser: return\n        try:\n            if not s.endswith(\"\\n\"): s += \"\\n\"\n            ser.write(s.encode(\"ascii\"))\n            log(f\"[SEND] {s.strip()}\")\n        except Exception as e:\n            log(f\"[ERROR] write: {e}\")\n\n    last_poll = 0.0\n    while True:\n        # 1) è™•ç†ä¾†è‡ª GUI çš„æŒ‡ä»¤\n        drained = 0\n        while drained < 50:\n            try:\n                msg = cmd_q.get_nowait()\n            except queue.Empty:\n                break\n\n            t = msg.get(\"type\")\n            if t == \"quit\":\n                close_port(); return\n            elif t == \"open\":\n                open_port(msg[\"port\"], msg[\"baud\"])\n            elif t == \"close\":\n                close_port()\n            elif t == \"set_interval\":\n                interval = max(0.01, float(msg[\"interval\"]))\n            elif t == \"set_mode\":\n                mode = msg[\"mode\"]\n                send_line(f\"MODE {mode}\")\n                pause_until = time.monotonic() + 0.2\n            elif t == \"velocity\":\n                vx, vy, wz = float(msg[\"vx\"]), float(msg[\"vy\"]), float(msg[\"wz\"])\n            elif t == \"raw\":\n                send_line(msg[\"text\"])\n                pause = float(msg.get(\"pause_ms\", 0)) / 1000.0\n                if pause > 0: pause_until = time.monotonic() + pause\n            drained += 1\n\n        # 2) è®€å–åºåˆ—è¼¸å…¥ï¼ˆéé˜»å¡ï¼‰\n        if ser:\n            try:\n                n = ser.in_waiting\n                if n:\n                    buf += ser.read(n)\n                    while b\"\\n\" in buf:\n                        line, buf = buf.split(b\"\\n\", 1)\n                        try: text = line.decode(\"utf-8\", \"replace\").rstrip(\"\\r\")\n                        except: text = str(line)\n                        log(text)\n            except Exception as e:\n                log(f\"[ERROR] read: {e}\")\n\n        # 3) é€±æœŸæ€§å»£æ’­ vx,vy,wzï¼ˆåªåœ¨ CHASSIS ä¸”æœªæš«åœï¼‰\n        now = time.monotonic()\n        if ser and mode == MODE_CHASSIS and now >= next_tx and now >= pause_until:\n            payload = f\"{vx:.2f},{vy:.2f},{wz:.2f}\\n\"\n            try:\n                ser.write(payload.encode(\"ascii\"))\n            except Exception as e:\n                log(f\"[ERROR] write (bg): {e}\")\n            next_tx = now + interval\n\n        # 4) å¾®ç¡é¿å…åƒæ»¿ CPU\n        time.sleep(0.002)\n\n\n# ====== GUI ä¸»ç¨‹åº ======\nclass App(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.title(\"Mecanum Serial é™æ§å™¨ï¼ˆå¤šé€²ç¨‹ï¼›ä¸é˜»å¡ï¼‰\")\n        self.geometry(\"760x700\"); self.resizable(False, False)\n\n        # èˆ‡å­ç¨‹åºçš„ IPC ä½‡åˆ—\n        self.cmd_q = mp.Queue(maxsize=500)\n        self.log_q = mp.Queue(maxsize=1000)\n        self.worker = None\n\n        # ç‹€æ…‹\n        self.mode_wanted = MODE_CHASSIS\n        self.mode_current = None\n        self.last_mode_change = 0.0\n        self.speed_scale = tk.DoubleVar(value=0.6)\n        self._moving_prev = False\n\n        # éµç›¤æ——æ¨™\n        self.k = {\"w\":False,\"a\":False,\"s\":False,\"d\":False,\"left\":False,\"right\":False,\"up\":False,\"down\":False}\n        self.vx = self.vy = self.wz = 0.0\n\n        # UI\n        self._build_ui()\n        self._bind_keys()\n\n        # å®šæ™‚å™¨\n        self.after(80,  self._pump_logs)\n        self.after(50,  self._ui_tick)\n\n        # é€Ÿåº¦èª¿æ•´é€£æŒ‰ç›¸é—œ\n        self._speed_step = 0.05\n        self._speed_repeat_job = None\n        self._speed_repeat_dir = 0\n\n    # --- UI ---\n    def _build_ui(self):\n        frm = ttk.Frame(self, padding=8); frm.pack(fill=tk.BOTH, expand=True)\n\n        row=0\n        ttk.Label(frm, text=\"Serial Portï¼š\").grid(column=0,row=row,sticky=tk.W)\n        self.port_var = tk.StringVar(value=\"\")\n        self.port_combo = ttk.Combobox(frm, width=20, textvariable=self.port_var, state=\"readonly\")\n        self._rescan_ports(); self.port_combo.grid(column=1,row=row,sticky=tk.W)\n        ttk.Button(frm, text=\"é‡æ–°æƒæ\", command=self._rescan_ports).grid(column=2,row=row,sticky=tk.W)\n\n        row+=1\n        ttk.Label(frm, text=\"Baud Rateï¼š\").grid(column=0,row=row,sticky=tk.W)\n        self.baud_var = tk.IntVar(value=DEFAULT_BAUD)\n        ttk.Entry(frm, textvariable=self.baud_var, width=10).grid(column=1,row=row,sticky=tk.W)\n\n        row+=1\n        ttk.Label(frm, text=\"é€è¨Šé–“éš” (s)ï¼š\").grid(column=0,row=row,sticky=tk.W)\n        self.interval_var = tk.DoubleVar(value=SEND_INTERVAL)\n        ttk.Entry(frm, textvariable=self.interval_var, width=8).grid(column=1,row=row,sticky=tk.W)\n        ttk.Button(frm, text=\"å¥—ç”¨é–“éš”\", command=self._apply_interval).grid(column=2,row=row,sticky=tk.W)\n\n        row+=1\n        ttk.Label(frm, text=\"é€Ÿåº¦å€ç‡ (Scale)ï¼š\").grid(column=0,row=row,sticky=tk.W)\n        ttk.Scale(frm, from_=0.0,to=1.0,variable=self.speed_scale,orient=tk.HORIZONTAL,length=320,\n                  command=lambda v:self._on_scale()).grid(column=1,row=row,columnspan=2,sticky=tk.W)\n\n        row+=1\n        self.mode_lbl = ttk.Label(frm, text=\"æ§åˆ¶æ¨¡å¼ï¼šCHASSISï¼ˆè‡ªå‹•ï¼‰\")\n        self.mode_lbl.grid(column=0,row=row,columnspan=3,sticky=tk.W,pady=(6,6))\n\n        row+=1\n        ttk.Label(\n            frm,\n            text=\"æ“ä½œï¼šW/S å‰å¾Œ  A/D å·¦å³  â†/â†’ æ—‹è½‰  â†‘/â†“ èª¿é€Ÿ   F/R/S=æ­¥é€²   1/2/3=Servo 60/90/120   NEO=-100..100\"\n        ).grid(column=0,row=row,columnspan=3,sticky=tk.W)\n\n        row+=1\n        btn = ttk.Frame(frm); btn.grid(column=0,row=row,columnspan=3,sticky=tk.W,pady=(6,6))\n        ttk.Button(btn, text=\"å•Ÿå‹•\", command=self._start_worker).grid(column=0,row=0,padx=6)\n        ttk.Button(btn, text=\"åœæ­¢\", command=self._stop_worker).grid(column=1,row=0,padx=6)\n        ttk.Button(btn, text=\"æ­¸é›¶(vx,vy,wz)\", command=self._zero_motion).grid(column=2,row=0,padx=6)\n        ttk.Button(btn, text=\"STATUS\", command=lambda:self._send_raw(\"STATUS\", pause_ms=400)).grid(column=3,row=0,padx=6)\n\n        row+=1\n        cur = ttk.LabelFrame(frm, text=\"ç›®å‰æ•¸å€¼ï¼ˆå·²ä¹˜é€Ÿåº¦å€ç‡ï¼‰\"); cur.grid(column=0,row=row,columnspan=3,sticky=tk.EW)\n        self.vx_lbl = ttk.Label(cur,text=\"vx: 0.00\"); self.vx_lbl.grid(column=0,row=0,padx=8,pady=6,sticky=tk.W)\n        self.vy_lbl = ttk.Label(cur,text=\"vy: 0.00\"); self.vy_lbl.grid(column=1,row=0,padx=8,pady=6,sticky=tk.W)\n        self.wz_lbl = ttk.Label(cur,text=\"wz: 0.00\"); self.wz_lbl.grid(column=2,row=0,padx=8,pady=6,sticky=tk.W)\n        self.sp_lbl = ttk.Label(cur,text=f\"é€Ÿåº¦å€ç‡: {self.speed_scale.get():.2f}\"); self.sp_lbl.grid(column=3,row=0,padx=8,pady=6,sticky=tk.W)\n\n        row+=1\n        stp = ttk.LabelFrame(frm, text=\"æ­¥é€²æ§åˆ¶\"); stp.grid(column=0,row=row,columnspan=3,sticky=tk.W+tk.E)\n        ttk.Button(stp,text=\"F\",command=lambda:self._stepper(\"F\")).grid(column=0,row=0,padx=6,pady=6)\n        ttk.Button(stp,text=\"R\",command=lambda:self._stepper(\"R\")).grid(column=1,row=0,padx=6,pady=6)\n        ttk.Button(stp,text=\"S(æŠ±æ­»)\",command=lambda:self._stepper(\"S\")).grid(column=2,row=0,padx=6,pady=6)\n        ttk.Label(stp,text=\"ï¼ˆéµç›¤ F / R / X=åœï¼‰\").grid(column=3,row=0,padx=8,pady=6,sticky=tk.W)\n\n        row+=1\n        # æ–°å¢ Servo æ§åˆ¶å€\n        srv = ttk.LabelFrame(frm, text=\"Servoï¼ˆpin10ï¼šS1/S2/S3ï¼‰\")\n        srv.grid(column=0,row=row,columnspan=3,sticky=tk.W+tk.E)\n        ttk.Button(srv, text=\"S1 (60Â°)\",  command=lambda:self._servo_angle(\"S1\")).grid(column=0,row=0,padx=6,pady=6)\n        ttk.Button(srv, text=\"S2 (90Â°)\",  command=lambda:self._servo_angle(\"S2\")).grid(column=1,row=0,padx=6,pady=6)\n        ttk.Button(srv, text=\"S3 (120Â°)\", command=lambda:self._servo_angle(\"S3\")).grid(column=2,row=0,padx=6,pady=6)\n        ttk.Label(srv,text=\"ï¼ˆéµç›¤ 1 / 2 / 3ï¼‰\").grid(column=3,row=0,padx=8,pady=6,sticky=tk.W)\n\n        row+=1\n        neo = ttk.LabelFrame(frm, text=\"NEO é€Ÿåº¦ï¼ˆ-100..100ï¼‰\"); neo.grid(column=0,row=row,columnspan=3,sticky=tk.W+tk.E)\n        self.neo_var = tk.StringVar(value=\"0\")\n        ttk.Entry(neo, textvariable=self.neo_var, width=8).grid(column=0,row=0,padx=(6,6),pady=6,sticky=tk.W)\n        ttk.Button(neo,text=\"é€å‡º\",command=self._send_neo).grid(column=1,row=0,padx=(0,6),pady=6,sticky=tk.W)\n        ttk.Label(neo,text=\"ï¼ˆè¼¸å…¥å¾ŒæŒ‰ Enter ä¹Ÿå¯é€ï¼‰\").grid(column=2,row=0,padx=6,pady=6,sticky=tk.W)\n\n        row+=1\n        self.info_lbl = ttk.Label(frm, text=\"ç‹€æ…‹ï¼šæœªé€£ç·š\"); self.info_lbl.grid(column=0,row=row,sticky=tk.W)\n        self.freq_lbl = ttk.Label(frm, text=f\"é »ç‡: {1.0/self.interval_var.get():.1f} Hz\"); self.freq_lbl.grid(column=1,row=row,sticky=tk.W,padx=12)\n\n        row+=1\n        lf = ttk.LabelFrame(frm, text=\"Serial Log (MEGA -> PC)\"); lf.grid(column=0,row=row,columnspan=3,sticky=tk.NSEW,pady=(8,0))\n        self.log = scrolledtext.ScrolledText(lf,height=12,width=88,state=\"disabled\",wrap=\"none\")\n        self.log.pack(fill=tk.BOTH, expand=True, padx=4, pady=4)\n\n        row+=1\n        raw = ttk.LabelFrame(frm, text=\"Raw æŒ‡ä»¤ï¼ˆSTATUS / STOP / F / R / S / S1 / S2 / S3 / -100..100 / vx,vy,wz / MODE ...ï¼‰\")\n        raw.grid(column=0,row=row,columnspan=3,sticky=tk.EW,pady=(6,0))\n        self.raw_var = tk.StringVar(value=\"STATUS\")\n        ttk.Entry(raw, textvariable=self.raw_var, width=56).grid(column=0,row=0,padx=(6,6))\n        ttk.Button(raw, text=\"é€å‡º Raw\", command=lambda:self._send_raw(self.raw_var.get())).grid(column=1,row=0)\n\n        self.protocol(\"WM_DELETE_WINDOW\", self._on_close)\n        # Entry å…§æŒ‰ Enter é€ NEO\n        self.bind_class(\"TEntry\",\"<Return>\", lambda e:self._send_neo())\n\n    def _rescan_ports(self):\n        ports = [p.device for p in serial.tools.list_ports.comports()] or [\"(none)\"]\n        self.port_combo[\"values\"] = ports\n        if ports and ports[0] != \"(none)\":\n            self.port_var.set(ports[0])\n\n    def _apply_interval(self):\n        val = max(0.01, float(self.interval_var.get()))\n        self.interval_var.set(val)\n        self.freq_lbl.config(text=f\"é »ç‡: {1.0/val:.1f} Hz\")\n        self._send_cmd({\"type\":\"set_interval\",\"interval\":val})\n\n    # --- Worker æ§åˆ¶ ---\n    def _start_worker(self):\n        if self.worker and self.worker.is_alive():\n            self._append(\"[INFO] å·²åœ¨åŸ·è¡Œ\")\n            return\n        self.worker = mp.Process(target=serial_worker, args=(self.cmd_q, self.log_q), daemon=True)\n        self.worker.start()\n        self._append(\"[INFO] worker å•Ÿå‹•\")\n        # é–‹ port\n        p = self.port_var.get().strip()\n        if not p or p == \"(none)\":\n            self._append(\"[WARN] è«‹å…ˆé¸æ“‡ Serial Port\")\n        else:\n            self._send_cmd({\"type\":\"open\",\"port\":p,\"baud\":int(self.baud_var.get())})\n            self.info_lbl.config(text=f\"ç‹€æ…‹ï¼šé€£ç·šä¸­ â†’ {p} @ {self.baud_var.get()}\")\n            # 1.8s å¾ŒåŒæ­¥æ¨¡å¼\n            self.after(1800, lambda:self._ensure_mode(self.mode_wanted, force=True))\n\n    def _stop_worker(self):\n        self._send_cmd({\"type\":\"close\"})\n        self.info_lbl.config(text=\"ç‹€æ…‹ï¼šæœªé€£ç·š\")\n\n    def _on_close(self):\n        self._send_cmd({\"type\":\"quit\"})\n        try:\n            if self.worker: self.worker.join(timeout=0.2)\n        except: pass\n        self.destroy()\n\n    def _send_cmd(self, msg):\n        try: self.cmd_q.put_nowait(msg)\n        except queue.Full: self._append(\"[WARN] cmd queue full\")\n\n    # --- å‹•ä½œï¼éµç›¤ ---\n    def _bind_keys(self):\n        def press(ev):\n            k = ev.keysym.lower()\n            # é€Ÿåº¦èª¿æ•´ï¼ˆâ†‘ / â†“ï¼‰\n            if k == \"up\":\n                self.k[\"up\"] = True\n                self._change_speed(self._speed_step)\n                self._start_speed_repeat(+1)\n                return\n            if k == \"down\":\n                self.k[\"down\"] = True\n                self._change_speed(-self._speed_step)\n                self._start_speed_repeat(-1)\n                return\n\n            # æ­¥é€²å¿«æ·éµï¼ˆF/R/S=Xï¼‰\n            if k == \"f\": self._stepper(\"F\"); return\n            if k == \"r\": self._stepper(\"R\"); return\n            if k == \"x\": self._stepper(\"S\"); return\n\n            # Servo å¿«æ·éµï¼ˆ1/2/3ï¼‰\n            if k == \"1\": self._servo_angle(\"S1\"); return\n            if k == \"2\": self._servo_angle(\"S2\"); return\n            if k == \"3\": self._servo_angle(\"S3\"); return\n\n            # ç§»å‹•éµ\n            if k in (\"w\",\"a\",\"s\",\"d\",\"left\",\"right\"):\n                self.k[k] = True\n                self._update_motion_from_keys()\n\n        def release(ev):\n            k = ev.keysym.lower()\n            if k in (\"up\",\"down\"):\n                self.k[k] = False\n                self._stop_speed_repeat()\n                return\n            if k in (\"w\",\"a\",\"s\",\"d\",\"left\",\"right\"):\n                self.k[k] = False\n                self._update_motion_from_keys()\n\n        self.bind(\"<KeyPress>\",  press)\n        self.bind(\"<KeyRelease>\", release)\n\n        # NEO è¼¸å…¥æ¡†æŒ‰ Enter ç›´æ¥é€å‡º\n        self.bind_class(\"TEntry\", \"<Return>\", lambda e: self._send_neo())\n\n        # é—œçª—\n        self.protocol(\"WM_DELETE_WINDOW\", self._on_close)\n\n    # --- é€Ÿåº¦å€ç‡é€£æŒ‰ç”¨ ---\n    def _change_speed(self, delta):\n        v = float(self.speed_scale.get())\n        v = max(0.0, min(1.0, v + delta))\n        self.speed_scale.set(v)\n        self.sp_lbl.config(text=f\"é€Ÿåº¦å€ç‡: {v:.2f}\")\n\n    def _start_speed_repeat(self, direction):\n        if self._speed_repeat_job is not None:\n            return\n        self._speed_repeat_dir = direction\n        def _repeat():\n            if (self._speed_repeat_dir > 0 and not self.k[\"up\"]) or \\\n               (self._speed_repeat_dir < 0 and not self.k[\"down\"]):\n                self._speed_repeat_job = None\n                return\n            self._change_speed(self._speed_step * self._speed_repeat_dir)\n            self._speed_repeat_job = self.after(120, _repeat)\n        self._speed_repeat_job = self.after(400, _repeat)\n\n    def _stop_speed_repeat(self):\n        if self._speed_repeat_job is not None:\n            self.after_cancel(self._speed_repeat_job)\n            self._speed_repeat_job = None\n\n    def _on_scale(self):\n        self.sp_lbl.config(text=f\"é€Ÿåº¦å€ç‡: {self.speed_scale.get():.2f}\")\n\n    def _update_motion_from_keys(self):\n        vx = vy = wz = 0.0\n        if self.k[\"w\"] and not self.k[\"s\"]: vx = 1.0\n        elif self.k[\"s\"] and not self.k[\"w\"]: vx = -1.0\n        if self.k[\"d\"] and not self.k[\"a\"]: vy = 1.0\n        elif self.k[\"a\"] and not self.k[\"d\"]: vy = -1.0\n        if self.k[\"left\"] and not self.k[\"right\"]: wz = -1.0\n        elif self.k[\"right\"] and not self.k[\"left\"]: wz = 1.0\n\n        moving = (vx!=0.0 or vy!=0.0 or wz!=0.0)\n        self.vx, self.vy, self.wz = vx, vy, wz\n\n        # å‚³çµ¦å­ç¨‹åºç•¶å‰é€Ÿåº¦ï¼ˆå­ç¨‹åºè‡ªè¡Œé€±æœŸå»£æ’­ï¼‰\n        sp = float(self.speed_scale.get())\n        self._send_cmd({\"type\":\"velocity\",\"vx\":vx*sp,\"vy\":vy*sp,\"wz\":wz*sp})\n\n        # ç”±ã€Œéœæ­¢â†’é–‹å§‹å‹•ã€é‚£ä¸€åˆ»åˆ‡åˆ° CHASSIS\n        if moving and not self._moving_prev:\n            self._ensure_mode(MODE_CHASSIS)\n        self._moving_prev = moving\n\n    def _zero_motion(self):\n        self.vx = self.vy = self.wz = 0.0\n        self._send_cmd({\"type\":\"velocity\",\"vx\":0.0,\"vy\":0.0,\"wz\":0.0})\n\n    def _ensure_mode(self, target, force=False):\n        now = time.monotonic()\n        if not force and self.mode_current == target: return\n        if not force and (now - self.last_mode_change) < 0.35: return\n        self.last_mode_change = now\n        self.mode_wanted = target\n        # æ¨‚è§€æ›´æ–° UIï¼Œä¸¦é€šçŸ¥å­ç¨‹åº\n        self.mode_current = target\n        self.mode_lbl.config(text=f\"æ§åˆ¶æ¨¡å¼ï¼š{target}ï¼ˆè‡ªå‹•ï¼‰\")\n        self._send_cmd({\"type\":\"set_mode\",\"mode\":target})\n\n    # --- å‘½ä»¤ ---\n    def _stepper(self, cmd):\n        if cmd not in (\"F\",\"R\",\"S\"): return\n        self._ensure_mode(MODE_SHOOTER)\n        self._send_raw(cmd)\n\n    def _servo_angle(self, cmd):\n        # cmd: \"S1\"/\"S2\"/\"S3\"\n        if cmd not in (\"S1\",\"S2\",\"S3\"):\n            return\n        self._ensure_mode(MODE_SHOOTER)\n        self._send_raw(cmd)\n\n    def _send_neo(self):\n        s = self.neo_var.get().strip()\n        try: v = int(s)\n        except: \n            self._append(\"[WARN] NEO é€Ÿåº¦éœ€ç‚ºæ•´æ•¸ -100..100\"); return\n        v = max(-100, min(100, v))\n        self._ensure_mode(MODE_SHOOTER)\n        self._send_raw(str(v))\n\n    def _send_raw(self, txt, pause_ms=0):\n        up = txt.upper().strip()\n        # F/R/S/S1/S2/S3 æˆ– ç´”æ•¸å­— â†’ SHOOTER\n        if up in (\"F\",\"R\",\"S\",\"S1\",\"S2\",\"S3\") or (txt.lstrip(\"-\").isdigit() and up!=\"MODE\"):\n            self._ensure_mode(MODE_SHOOTER)\n        elif \",\" in txt and not up.startswith(\"MODE \"):\n            # vx,vy,wz é¡ â†’ CHASSIS\n            self._ensure_mode(MODE_CHASSIS)\n        elif up.startswith(\"MODE \"):\n            tgt = up.split(None,1)[1].strip()\n            if tgt in (MODE_CHASSIS, MODE_SHOOTER):\n                self._ensure_mode(tgt, force=True)\n        self._send_cmd({\"type\":\"raw\",\"text\":txt,\"pause_ms\":pause_ms})\n\n    # --- æ—¥èªŒ/ç•«é¢æ›´æ–° ---\n    def _append(self, txt):\n        self.log.configure(state=\"normal\")\n        self.log.insert(tk.END, txt + \"\\n\")\n        self.log.see(tk.END)\n        self.log.configure(state=\"disabled\")\n\n    def _pump_logs(self):\n        try:\n            while True:\n                line = self.log_q.get_nowait()\n                self._append(line)\n                if line.startswith(\"[OPEN]\"):\n                    self.info_lbl.config(text=line.replace(\"[OPEN]\",\"ç‹€æ…‹ï¼šå·²é€£ç·š\"))\n                if line.startswith(\"[CLOSED]\"):\n                    self.info_lbl.config(text=\"ç‹€æ…‹ï¼šæœªé€£ç·š\")\n        except queue.Empty:\n            pass\n        self.after(80, self._pump_logs)\n\n    def _ui_tick(self):\n        sp = float(self.speed_scale.get())\n        self.vx_lbl.config(text=f\"vx: {self.vx*sp:.2f}\")\n        self.vy_lbl.config(text=f\"vy: {self.vy*sp:.2f}\")\n        self.wz_lbl.config(text=f\"wz: {self.wz*sp:.2f}\")\n        self.after(50, self._ui_tick)\n\n\nif __name__ == \"__main__\":\n    app = App()\n    app.mainloop()\n"}
{"path": "pi_detect.py", "extension": ".py", "size_bytes": 4674, "modified_time": "2025-11-25 19:21:29", "sha256": "6da74e01d8658a100ad66d650a14e9fca29ac0c212a7cfe3e38864126ec717d2", "is_text": true, "encoding": "utf-8", "truncated": false, "content": "# conda activate tel_env\n#python pi_detect.py\nimport cv2\nimport time\nfrom ultralytics import YOLO\n\n# ==========================================\n#  å…¨åŸŸè®Šæ•¸è¨­å®š (User Configuration)\n# ==========================================\n\n# 1. æ¨¡å‹è·¯å¾‘ (å»ºè­°ä½¿ç”¨ .onnx ä»¥ç²å¾— Pi 5 æœ€ä½³æ•ˆèƒ½)\nMODEL_PATH = \"best.onnx\"  # å¦‚æœè¦ç”¨ .ptï¼Œæ”¹ç‚º \"best.pt\"\n\n# 2. è‡ªä¿¡åº¦é–¾å€¼ (0.0 ~ 1.0)\n# ä½æ–¼æ­¤åˆ†æ•¸çš„ç‰©ä»¶ä¸æœƒè¢«è¦–ç‚ºåµæ¸¬æˆåŠŸ\nCONF_THRESHOLD = 0.5\n\n# 3. ç¯„åœå€åŸŸå¯¬åº¦ç™¾åˆ†æ¯” (0.1 ~ 0.9)\n# è¨­å®š 0.3 ä»£è¡¨ç•«é¢ä¸­é–“ 30% ç‚ºã€Œç›®æ¨™å€åŸŸã€ï¼Œå·¦å³å…©å´æœƒæœ‰é‚Šç•Œç·š\nZONE_WIDTH_PERCENT = 0.3 \n\n# 4. è¾¨è­˜å½±åƒå¹€ç‡ (ç›¸æ©Ÿè¨­å®š)\n# è¨­å®šç›¸æ©Ÿå¸Œæœ›æ“·å–çš„ FPS (å¯¦éš› FPS ä»å–æ±ºæ–¼æ¨è«–é€Ÿåº¦)\nTARGET_FPS = 5\n\n# æ”å½±æ©Ÿè§£æåº¦è¨­å®š (è¶Šä½è¶Šå¿«ï¼Œå»ºè­° 640x480 æˆ– 320x240)\nFRAME_WIDTH = 240\nFRAME_HEIGHT = 180\n\n# ==========================================\n#  ä¸»ç¨‹å¼\n# ==========================================\n\ndef main():\n    # 1. è¼‰å…¥æ¨¡å‹\n    print(f\"æ­£åœ¨è¼‰å…¥æ¨¡å‹: {MODEL_PATH} ...\")\n    try:\n        # task='detect' æœ‰åŠ©æ–¼åŠ é€Ÿè¼‰å…¥\n        model = YOLO(MODEL_PATH, task='detect')\n        print(\"æ¨¡å‹è¼‰å…¥æˆåŠŸï¼\")\n    except Exception as e:\n        print(f\"éŒ¯èª¤: ç„¡æ³•è¼‰å…¥æ¨¡å‹ã€‚è«‹ç¢ºèªæª”æ¡ˆæ˜¯å¦å­˜åœ¨ã€‚\\n{e}\")\n        return\n\n    # 2. åˆå§‹åŒ–æ”å½±æ©Ÿ\n    cap = cv2.VideoCapture(0)\n    \n    # è¨­å®šç›¸æ©Ÿåƒæ•¸\n    cap.set(cv2.CAP_PROP_FRAME_WIDTH, FRAME_WIDTH)\n    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, FRAME_HEIGHT)\n    cap.set(cv2.CAP_PROP_FPS, TARGET_FPS)\n\n    if not cap.isOpened():\n        print(\"éŒ¯èª¤: ç„¡æ³•é–‹å•Ÿæ”å½±æ©Ÿã€‚è«‹æª¢æŸ¥é€£æ¥ã€‚\")\n        return\n\n    print(f\"é–‹å§‹è¾¨è­˜... æŒ‰ 'q' éµé›¢é–‹\")\n    \n    # ç”¨æ–¼è¨ˆç®—å¯¦éš› FPS\n    prev_time = 0\n    \n    while True:\n        success, frame = cap.read()\n        if not success:\n            print(\"ç„¡æ³•è®€å–å½±åƒå¹€\")\n            break\n\n        # --- å€åŸŸè¨ˆç®—é‚è¼¯ ---\n        # å–å¾—ç•«é¢ä¸­å¿ƒé» X åº§æ¨™\n        center_x = FRAME_WIDTH // 2\n        \n        # è¨ˆç®—å·¦å³é‚Šç•Œçš„åƒç´ åç§»é‡ (ç¸½å¯¬åº¦ * ç™¾åˆ†æ¯” / 2)\n        offset = int(FRAME_WIDTH * ZONE_WIDTH_PERCENT / 2)\n        \n        # å®šç¾©å·¦é‚Šç•Œèˆ‡å³é‚Šç•Œ X åº§æ¨™\n        left_boundary = center_x - offset\n        right_boundary = center_x + offset\n\n        # --- 3. åŸ·è¡Œ AI æ¨è«– ---\n        # verbose=False é—œé–‰çµ‚ç«¯æ©Ÿå¤§é‡è¼¸å‡ºï¼Œstream=True ç¯€çœè¨˜æ†¶é«”\n        results = model.predict(frame, conf=CONF_THRESHOLD, verbose=False)\n\n        # --- 4. ç¹ªåœ–èˆ‡è³‡æ–™è™•ç† ---\n        # ç•«å‡º AI åµæ¸¬åˆ°çš„æ¡† (YOLO å…§å»ºç¹ªåœ–)\n        # ç‚ºäº†ä¸è¦†è“‹æ‰æˆ‘å€‘è¦ç•«çš„ç·šï¼Œæˆ‘å€‘å…ˆæŠŠçµæœç•«ä¸Šå»ï¼Œå†ç•«ç·š\n        annotated_frame = results[0].plot()\n\n        # ç•«ä¸­å¿ƒå‚ç›´ç·š (é»ƒè‰², å¯¬åº¦ 2)\n        cv2.line(annotated_frame, (center_x, 0), (center_x, FRAME_HEIGHT), (0, 255, 255), 2)\n\n        # ç•«ç¯„åœå€åŸŸå·¦é‚Šç•Œ (ç¶ è‰², å¯¬åº¦ 2)\n        cv2.line(annotated_frame, (left_boundary, 0), (left_boundary, FRAME_HEIGHT), (0, 255, 0), 2)\n\n        # ç•«ç¯„åœå€åŸŸå³é‚Šç•Œ (ç¶ è‰², å¯¬åº¦ 2)\n        cv2.line(annotated_frame, (right_boundary, 0), (right_boundary, FRAME_HEIGHT), (0, 255, 0), 2)\n\n        # (é¸ç”¨) æ¨™ç¤ºæ–‡å­—\n        cv2.putText(annotated_frame, \"Target Zone\", (left_boundary + 5, 20), \n                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 1)\n\n        # --- è™•ç†åµæ¸¬åˆ°çš„ç‰©ä»¶ (ç¯„ä¾‹é‚è¼¯) ---\n        # é€™è£¡ç¤ºç¯„å¦‚ä½•åˆ¤æ–·ç‰©ä»¶æ˜¯å¦åœ¨å€åŸŸå…§\n        for box in results[0].boxes:\n            # å–å¾—ç‰©ä»¶ä¸­å¿ƒé»\n            x1, y1, x2, y2 = box.xyxy[0]\n            obj_center_x = int((x1 + x2) / 2)\n            obj_center_y = int((y1 + y2) / 2)\n\n            # åˆ¤æ–·æ˜¯å¦åœ¨å€åŸŸå…§\n            if left_boundary < obj_center_x < right_boundary:\n                # å¦‚æœåœ¨å€åŸŸå…§ï¼Œç•«ä¸€å€‹å¯¦å¿ƒç´…é»åœ¨ç‰©ä»¶ä¸­å¿ƒ\n                cv2.circle(annotated_frame, (obj_center_x, obj_center_y), 5, (0, 0, 255), -1)\n                # ä½ å¯ä»¥åœ¨é€™è£¡åŠ å…¥ UART å‚³é€æŒ‡ä»¤ï¼Œä¾‹å¦‚ \"Shoot\" æˆ– \"Grab\"\n\n        # --- è¨ˆç®—ä¸¦é¡¯ç¤ºå¯¦éš› FPS ---\n        curr_time = time.time()\n        fps = 1 / (curr_time - prev_time)\n        prev_time = curr_time\n        \n        # é¡¯ç¤º FPS åœ¨å·¦ä¸Šè§’\n        cv2.putText(annotated_frame, f\"FPS: {fps:.1f}\", (10, 30), \n                    cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)\n\n        # --- 5. é¡¯ç¤ºç•«é¢ ---\n        cv2.imshow(\"Pi 5 YOLO Detection\", annotated_frame)\n\n        # æŒ‰ 'q' é€€å‡º\n        if cv2.waitKey(1) & 0xFF == ord('q'):\n            break\n\n    # é‡‹æ”¾è³‡æº\n    cap.release()\n    cv2.destroyAllWindows()\n\nif __name__ == \"__main__\":\n    main()"}
