
================================================================================
FILE: scan_folder.py
================================================================================
# scan_folder.py
# -*- coding: utf-8 -*-
import os, sys, csv, time, json, base64, hashlib
from collections import defaultdict

DEFAULT_TARGET = r"/home/tel/tel2025"

# ç•¥éçš„è³‡æ–™å¤¾
SKIP_DIRS = {
    ".git","__pycache__","node_modules",".venv","venv","env",
    "build","dist",".idea",".vscode",".pytest_cache",".mypy_cache",".cache"
}

# åªæŠŠ .py ç•¶ä½œæ–‡å­—æª”è™•ç†
TEXT_EXTS = {
    ".py",
}

# å…§å®¹è¼¸å‡ºæ§åˆ¶
MAX_TEXT_BYTES = 512 * 1024      # å–®ä¸€æ–‡å­—æª”æœ€å¤šè®€ 512 KB å…§å®¹
MAX_BINARY_BYTES = 0             # äºŒé€²ä½æª”æ˜¯å¦è¼¸å‡º base64ï¼ˆ0=ä¸è¼¸å‡ºï¼Œåªè¨˜éŒ„é›œæ¹Šèˆ‡ä¸­ç¹¼è³‡æ–™ï¼‰
ENCODING = "utf-8"               # æ–‡å­—è®€å–ç·¨ç¢¼ï¼ˆå¤±æ•—å‰‡ç”¨ errors='replace'ï¼‰

def is_probably_binary(path, ext) -> bool:
    if ext.lower() in TEXT_EXTS:
        return False
    try:
        with open(path, "rb") as f:
            head = f.read(4096)
        # æœ‰ NUL æˆ–å¤ªå¤šéå¯åˆ—å°æ§åˆ¶å­— â†’ è¦–ç‚ºäºŒé€²ä½
        if b"\x00" in head:
            return True
        nontext = sum(1 for b in head if b < 9 or (13 < b < 32) or b == 127)
        return nontext / max(1, len(head)) > 0.30
    except Exception:
        return True

def human_size(n: int) -> str:
    units = ["B","KB","MB","GB","TB"]
    i, f = 0, float(n)
    while f >= 1024 and i < len(units)-1:
        f /= 1024; i += 1
    return f"{f:.2f} {units[i]}"

def sha256_file(path: str) -> str:
    h = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(1024 * 1024), b""):
            h.update(chunk)
    return h.hexdigest()

def gen_tree(root: str, skip_dirs=SKIP_DIRS, max_files_per_dir=200) -> str:
    lines = []
    root = os.path.abspath(root)
    for current_root, dirs, files in os.walk(root):
        rel = os.path.relpath(current_root, root)
        depth = 0 if rel == "." else rel.count(os.sep) + 1
        indent = "    " * depth
        lines.append((os.path.basename(root) if rel == "." else f"{'    '*(depth-1)}â””â”€ {os.path.basename(current_root)}"))
        dirs[:] = [d for d in dirs if d not in skip_dirs]
        shown = 0
        for name in sorted(files):
            if shown >= max_files_per_dir:
                lines.append(f"{indent}â””â”€ ... ({len(files)-shown} more files)")
                break
            lines.append(f"{indent}â””â”€ {name}")
            shown += 1
    return "\n".join(lines)

def main():
    target = sys.argv[1] if len(sys.argv) >= 2 else DEFAULT_TARGET
    target = os.path.abspath(os.path.expanduser(target))
    if not os.path.isdir(target):
        print(f"âŒ æ‰¾ä¸åˆ°è³‡æ–™å¤¾ï¼š{target}")
        sys.exit(1)

    out_csv  = os.path.join(target, "files_report.csv")
    out_tree = os.path.join(target, "files_tree.txt")
    out_jsonl = os.path.join(target, "files_content.jsonl")
    out_alltxt = os.path.join(target, "ALL_TEXTS.txt")

    by_ext_count = defaultdict(int)
    by_ext_size = defaultdict(int)
    total_files = total_bytes = 0

    # å…ˆå¯« CSVï¼ˆä¸­ç¹¼è³‡æ–™ï¼‰
    with open(out_csv, "w", newline="", encoding="utf-8-sig") as fcsv, \
         open(out_jsonl, "w", encoding="utf-8") as fjsonl, \
         open(out_alltxt, "w", encoding="utf-8", errors="replace") as falltxt:

        writer = csv.writer(fcsv)
        writer.writerow([
            "relative_path", "extension", "size_bytes", "size_human",
            "modified_time", "is_text", "line_count", "sha256"
        ])

        for root_dir, dirs, files in os.walk(target):
            dirs[:] = [d for d in dirs if d not in SKIP_DIRS]
            for fname in files:
                ext = os.path.splitext(fname)[1].lower()

                # åªè™•ç† .py æª”ï¼Œå…¶å®ƒå…¨éƒ¨ç•¥é
                if ext != ".py":
                    continue

                fpath = os.path.join(root_dir, fname)
                rel = os.path.relpath(fpath, target)

                try:
                    stat = os.stat(fpath)
                except OSError:
                    continue

                size = stat.st_size
                mtime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(stat.st_mtime))
                is_bin = is_probably_binary(fpath, ext)
                sha256 = sha256_file(fpath)

                line_count = ""
                text_preview = ""
                encoding_used = None

                if not is_bin:
                    # è®€éƒ¨åˆ†æ–‡å­—å…§å®¹ï¼ˆé™åˆ¶å¤§å°ï¼‰
                    try:
                        with open(fpath, "r", encoding=ENCODING, errors="replace") as fr:
                            content = fr.read(min(MAX_TEXT_BYTES, size))
                            encoding_used = ENCODING
                            text_preview = content
                            line_count = content.count("\n") + (1 if content and not content.endswith("\n") else 0)
                    except Exception:
                        pass

                    # å¯«å…¥ ALL_TEXTS åŒ¯ç¸½
                    falltxt.write("\n" + "="*80 + "\n")
                    falltxt.write(f"FILE: {rel}\n")
                    falltxt.write("="*80 + "\n")
                    if text_preview:
                        falltxt.write(text_preview)
                        if size > MAX_TEXT_BYTES:
                            falltxt.write("\n[... TRUNCATED ...]\n")
                    else:
                        falltxt.write("[[EMPTY OR UNREADABLE TEXT]]\n")

                    # JSONLï¼šæ–‡å­—
                    json.dump({
                        "path": rel,
                        "extension": ext or "(noext)",
                        "size_bytes": size,
                        "modified_time": mtime,
                        "sha256": sha256,
                        "is_text": True,
                        "encoding": encoding_used or "utf-8",
                        "truncated": bool(size > MAX_TEXT_BYTES),
                        "content": text_preview
                    }, fjsonl, ensure_ascii=False)
                    fjsonl.write("\n")

                else:
                    # JSONLï¼šäºŒé€²ä½ï¼ˆé è¨­ä¸å«å…§å®¹ï¼Œåªè¨˜é›œæ¹Šèˆ‡ä¸­ç¹¼è³‡æ–™ï¼›éœ€è¦å¯æ”¹ MAX_BINARY_BYTESï¼‰
                    b64 = None
                    if MAX_BINARY_BYTES > 0:
                        try:
                            with open(fpath, "rb") as fb:
                                raw = fb.read(min(MAX_BINARY_BYTES, size))
                            b64 = base64.b64encode(raw).decode("ascii")
                        except Exception:
                            b64 = None

                    json.dump({
                        "path": rel,
                        "extension": ext or "(noext)",
                        "size_bytes": size,
                        "modified_time": mtime,
                        "sha256": sha256,
                        "is_text": False,
                        "base64_bytes": b64,
                        "truncated": bool(size > MAX_BINARY_BYTES) if MAX_BINARY_BYTES > 0 else None
                    }, fjsonl)
                    fjsonl.write("\n")

                # CSVï¼ˆä¸­ç¹¼è³‡æ–™ä¸€è¦½ï¼‰
                writer.writerow([
                    rel, ext or "(noext)", size, human_size(size), mtime,
                    int(not is_bin), line_count, sha256
                ])

                by_ext_count[ext] += 1
                by_ext_size[ext] += size
                total_files += 1
                total_bytes += size

    # ç”¢ç”Ÿæ¨¹ç‹€ï¼ˆä»åˆ—å‡ºå…¨éƒ¨æª”æ¡ˆçµæ§‹ï¼‰
    with open(out_tree, "w", encoding="utf-8") as ftree:
        ftree.write(gen_tree(target))

    # æ‘˜è¦
    print("ğŸ“ æƒæå®Œæˆï¼š", target)
    print(f"   æª”æ¡ˆç¸½æ•¸ï¼š{total_files}")
    print(f"   ç¸½å¤§å°  ï¼š{human_size(total_bytes)}")
    print("   ä¾å‰¯æª”åçµ±è¨ˆï¼ˆå‰ 15 åï¼‰ï¼š")
    top = sorted(by_ext_count.items(), key=lambda kv: by_ext_size[kv[0]], reverse=True)[:15]
    for ext, cnt in top:
        print(f"   {ext or '(noext)':>8}  {cnt:>6} æª”  {human_size(by_ext_size[ext]):>10}")

    print(f"\nâœ… å·²è¼¸å‡ºï¼š\n  - {out_csv}\n  - {out_tree}\n  - {out_jsonl}\n  - {out_alltxt}")
    print("\nâš™ï¸ åƒæ•¸ï¼šMAX_TEXT_BYTES={}, MAX_BINARY_BYTES={}ï¼ˆå¯åœ¨æª”é ­èª¿æ•´ï¼‰".format(MAX_TEXT_BYTES, MAX_BINARY_BYTES))
    print("ğŸ’¡ JSONL å¯è¢« jq / pandas / BigQuery / Elasticsearch ç­‰ç›´æ¥ä½¿ç”¨ï¼›ALL_TEXTS.txt æ–¹ä¾¿äººå·¥æª¢è¦–ã€‚")

if __name__ == "__main__":
    main()

================================================================================
FILE: pi_remote_server.py
================================================================================
# pi_remote_server.py
# åŠŸèƒ½ï¼š
#   - å•Ÿå‹• mega1_controller.serial_worker æ§åˆ¶ åº•ç›¤+å°„æ‰‹ (æ§åˆ¶æ¿1)
#   - ä½¿ç”¨ aim.SerialLink æ§åˆ¶ ç„æº–å…©è»¸ (æ§åˆ¶æ¿2)
#   - é–‹ TCP ä¼ºæœå™¨ï¼Œæ¥å—ä¾†è‡ª PC çš„æ–‡å­—æŒ‡ä»¤

import socket
import threading
import multiprocessing as mp
import time

from mega1_controller import serial_worker, MODE_CHASSIS, MODE_SHOOTER, DEFAULT_BAUD
from aim import SerialLink, BAUD as AIM_BAUD

# === è«‹ä¾å¯¦éš›æƒ…æ³ä¿®æ”¹é€™å…©å€‹åºåˆ—åŸ åç¨± ===
MEGA1_PORT = "/dev/ttyUSB0"   # æ§åº•ç›¤+å°„æ‰‹çš„é‚£å¡Šæ§åˆ¶æ¿
AIM_PORT   = "/dev/ttyACM0"   # æ§ç ²å°ä»°è§’/æ–¹å‘çš„é‚£å¡Šæ¿å­

TCP_HOST = "0.0.0.0"
TCP_PORT = 5000

def start_mega_worker():
    """å•Ÿå‹• mega1_controller è£¡çš„ serial_worker å­ç¨‹åºï¼Œå›å‚³ (cmd_q, log_q, process)"""
    cmd_q = mp.Queue(maxsize=500)
    log_q = mp.Queue(maxsize=1000)

    p = mp.Process(target=serial_worker, args=(cmd_q, log_q), daemon=True)
    p.start()

    # é–‹å•Ÿ MEGA1 åºåˆ—åŸ 
    cmd_q.put({
        "type": "open",
        "port": MEGA1_PORT,
        "baud": DEFAULT_BAUD,
    })
    # åŒæ­¥é€è¨Šé–“éš”ï¼Œå¯è¦–éœ€è¦èª¿æ•´
    cmd_q.put({
        "type": "set_interval",
        "interval": 0.08,
    })

    return cmd_q, log_q, p

def start_aim_link():
    """å»ºç«‹ç¬¬äºŒå¡Šæ¿ (AIM) çš„ SerialLink"""
    link = SerialLink()
    link.open(AIM_PORT, AIM_BAUD)
    return link

def handle_client(conn, addr, cmd_q, aim_link):
    print(f"[CLIENT] {addr} é€£ç·šé€²ä¾†")
    mode_current = MODE_CHASSIS

    def set_mode(new_mode, force=False):
        nonlocal mode_current
        if not force and mode_current == new_mode:
            return
        mode_current = new_mode
        cmd_q.put({"type": "set_mode", "mode": new_mode})

    f = conn.makefile("r")  # è®“æˆ‘å€‘å¯ä»¥ç”¨ for line in f è®€
    try:
        for line in f:
            line = line.strip()
            if not line:
                continue

            print(f"[RECV] {addr}: {line}")
            parts = line.split()
            cmd = parts[0].upper()

            try:
                if cmd == "CHASSIS":
                    # CHASSIS vx vy wz
                    if len(parts) != 4:
                        conn.sendall(b"ERR CHASSIS usage: CHASSIS vx vy wz\n")
                        continue
                    vx = float(parts[1])
                    vy = float(parts[2])
                    wz = float(parts[3])
                    set_mode(MODE_CHASSIS)
                    cmd_q.put({"type": "velocity", "vx": vx, "vy": vy, "wz": wz})
                    conn.sendall(b"OK CHASSIS\n")

                elif cmd == "MODE":
                    # MODE CHASSIS / MODE SHOOTER
                    if len(parts) != 2:
                        conn.sendall(b"ERR MODE usage: MODE CHASSIS|SHOOTER\n")
                        continue
                    tgt = parts[1].upper()
                    if tgt not in (MODE_CHASSIS, MODE_SHOOTER):
                        conn.sendall(b"ERR MODE must be CHASSIS or SHOOTER\n")
                        continue
                    set_mode(tgt, force=True)
                    conn.sendall(b"OK MODE\n")

                elif cmd == "STEP":
                    # STEP F / STEP R / STEP S
                    if len(parts) != 2:
                        conn.sendall(b"ERR STEP usage: STEP F|R|S\n")
                        continue
                    sub = parts[1].upper()
                    if sub not in ("F", "R", "S"):
                        conn.sendall(b"ERR STEP must be F/R/S\n")
                        continue
                    set_mode(MODE_SHOOTER)
                    cmd_q.put({"type": "raw", "text": sub})
                    conn.sendall(b"OK STEP\n")

                elif cmd == "SERVO":
                    # SERVO S1 / SERVO S2 / SERVO S3
                    if len(parts) != 2:
                        conn.sendall(b"ERR SERVO usage: SERVO S1|S2|S3\n")
                        continue
                    sub = parts[1].upper()
                    if sub not in ("S1", "S2", "S3"):
                        conn.sendall(b"ERR SERVO must be S1/S2/S3\n")
                        continue
                    set_mode(MODE_SHOOTER)
                    cmd_q.put({"type": "raw", "text": sub})
                    conn.sendall(b"OK SERVO\n")

                elif cmd == "NEO":
                    # NEO -100..100
                    if len(parts) != 2:
                        conn.sendall(b"ERR NEO usage: NEO value(-100..100)\n")
                        continue
                    val = int(parts[1])
                    if val < -100: val = -100
                    if val > 100: val = 100
                    set_mode(MODE_SHOOTER)
                    cmd_q.put({"type": "raw", "text": str(val)})
                    conn.sendall(b"OK NEO\n")

                elif cmd == "AIM":
                    # AIM axis angle
                    if len(parts) != 3:
                        conn.sendall(b"ERR AIM usage: AIM axis angle\n")
                        continue
                    axis = int(parts[1])
                    angle = float(parts[2])
                    if axis not in (1, 2):
                        conn.sendall(b"ERR AIM axis must be 1 or 2\n")
                        continue
                    aim_link.send_angle(axis, angle)
                    conn.sendall(b"OK AIM\n")

                elif cmd == "RAW":
                    # RAW å¾Œé¢æ•´ä¸²éƒ½ä¸Ÿåˆ° MEGA (chassis/shooter é‚£å¡Š)
                    if len(parts) < 2:
                        conn.sendall(b"ERR RAW usage: RAW your_command\n")
                        continue
                    txt = line[4:].strip()  # å»æ‰ "RAW "
                    cmd_q.put({"type": "raw", "text": txt})
                    conn.sendall(b"OK RAW\n")

                elif cmd == "STATUS":
                    # ç°¡å–®å›æ‡‰ä¸€ä¸‹
                    conn.sendall(f"MODE={mode_current}\n".encode("utf-8"))

                elif cmd == "QUIT":
                    conn.sendall(b"BYE\n")
                    break

                else:
                    conn.sendall(b"ERR unknown command\n")

            except Exception as e:
                err = f"ERR exception: {e}\n"
                conn.sendall(err.encode("utf-8"))

    finally:
        print(f"[CLIENT] {addr} é›¢ç·š")
        conn.close()

def main():
    mp.freeze_support()

    print("[INFO] å•Ÿå‹• MEGA1 worker ...")
    cmd_q, log_q, worker = start_mega_worker()

    print("[INFO] å•Ÿå‹• AIM SerialLink ...")
    aim_link = start_aim_link()

    print(f"[INFO] å•Ÿå‹• TCP ä¼ºæœå™¨ {TCP_HOST}:{TCP_PORT}")
    srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    srv.bind((TCP_HOST, TCP_PORT))
    srv.listen(5)

    try:
        while True:
            conn, addr = srv.accept()
            th = threading.Thread(
                target=handle_client,
                args=(conn, addr, cmd_q, aim_link),
                daemon=True
            )
            th.start()
    finally:
        print("[INFO] é—œé–‰ä¼ºæœå™¨")
        srv.close()
        cmd_q.put({"type": "quit"})
        try:
            worker.join(timeout=1.0)
        except:
            pass
        aim_link.close()

if __name__ == "__main__":
    main()

================================================================================
FILE: aim.py
================================================================================
# aim.py
# æ–¹å‘éµï¼š
#   â† / â†’  : M1 (- / + 1Â°)
#   â†‘ / â†“  : M2 (+ / - 1Â°)
# å‚³é€æ ¼å¼ï¼š "1,<angle>\n" æˆ– "2,<angle>\n"
# åŠŸèƒ½é‡é»ï¼šå¯å¾ä¸‹æ‹‰é¸å–®é¸å– COMï¼Œé€£ç·š/æ–·ç·šã€é‡æ–°æ•´ç†å¯ç”¨åŸ 

import time
import tkinter as tk
from tkinter import ttk, messagebox
import serial
import serial.tools.list_ports

BAUD     = 115200
STEP_DEG = 1.0  # æ¯æ¬¡æŒ‰éµè®ŠåŒ–è§’åº¦

class SerialLink:
    def __init__(self):
        self.ser = None

    def open(self, port: str, baud: int = BAUD):
        self.close()
        try:
            self.ser = serial.Serial(port, baudrate=baud, timeout=0.1)
        except Exception as e:
            self.ser = None
            raise e
        # Arduino é€£ä¸Šæœƒ resetï¼Œçµ¦é»æ™‚é–“
        time.sleep(2.0)

    def is_open(self):
        return self.ser is not None and self.ser.is_open

    def send_angle(self, axis_id: int, angle: float):
        if not self.is_open():
            return
        msg = f"{axis_id},{angle:.3f}\n"
        try:
            self.ser.write(msg.encode("utf-8"))
        except Exception as e:
            # é€å¤±æ•—å°±æ–·ç·šï¼Œé¿å…ä¹‹å¾Œä¸€ç›´å ±éŒ¯
            try:
                self.close()
            finally:
                raise e

    def close(self):
        if self.ser:
            try:
                if self.ser.is_open:
                    self.ser.close()
            finally:
                self.ser = None

def list_serial_ports():
    # å›å‚³ [(é¡¯ç¤ºå­—ä¸², è£ç½®å­—ä¸²), ...]
    items = []
    for p in serial.tools.list_ports.comports():
        display = f"{p.device} â€” {p.description}"
        items.append((display, p.device))
    # è‹¥æ²’æ‰¾åˆ°ä»»ä½•è£ç½®ï¼Œä»å…è¨±æ‰‹å‹•è¼¸å…¥
    return items

class ControllerApp:
    def __init__(self, master):
        self.master = master
        self.master.title("Arrow Controller (é¸æ“‡ COMï¼šé€£ç·šå¾Œç”¨æ–¹å‘éµ)")
        self.master.geometry("420x180")

        self.link = SerialLink()
        self.m1_angle = 0.0
        self.m2_angle = 0.0

        # ===== ä¸Šæ–¹ï¼šCOM é¸æ“‡åˆ— =====
        top = ttk.Frame(master, padding=8)
        top.pack(fill="x")

        ttk.Label(top, text="é€£æ¥åŸ ï¼š").pack(side="left")
        self.port_var = tk.StringVar()
        self.port_combo = ttk.Combobox(top, textvariable=self.port_var, width=35)
        self.port_combo.pack(side="left", padx=6)
        self.port_combo.configure(state="normal")  # å¯æ‰‹å‹•è¼¸å…¥

        self.refresh_btn = ttk.Button(top, text="é‡æ–°æ•´ç†", command=self.refresh_ports)
        self.refresh_btn.pack(side="left", padx=4)

        self.connect_btn = ttk.Button(top, text="é€£ç·š", command=self.toggle_connect)
        self.connect_btn.pack(side="left", padx=4)

        # ===== ä¸­æ®µï¼šè§’åº¦é¡¯ç¤º =====
        mid = ttk.Frame(master, padding=8)
        mid.pack(fill="x")
        self.lbl1 = ttk.Label(mid, text=f"M1: {self.m1_angle:.3f}Â°", font=("Consolas", 16))
        self.lbl2 = ttk.Label(mid, text=f"M2: {self.m2_angle:.3f}Â°", font=("Consolas", 16))
        self.lbl1.pack(pady=2)
        self.lbl2.pack(pady=2)

        # ===== åº•éƒ¨ï¼šæç¤º/ç‹€æ…‹ =====
        bot = ttk.Frame(master, padding=8)
        bot.pack(fill="x")
        self.hint = ttk.Label(bot, text="â†/â†’ æ§ M1 | â†‘/â†“ æ§ M2 | æ¯æ¬¡ Â±1Â°", foreground="#444")
        self.hint.pack(side="left")
        self.status_var = tk.StringVar(value="æœªé€£ç·š")
        self.status = ttk.Label(bot, textvariable=self.status_var, foreground="#A00")
        self.status.pack(side="right")

        # ç¶å®šæ–¹å‘éµï¼ˆåªåœ¨å·²é€£ç·šæ™‚å‹•ä½œï¼‰
        master.bind_all("<Left>",  self.on_left)
        master.bind_all("<Right>", self.on_right)
        master.bind_all("<Up>",    self.on_up)
        master.bind_all("<Down>",  self.on_down)

        master.protocol("WM_DELETE_WINDOW", self.on_close)

        # åˆå§‹åŒ–å¯ç”¨åŸ 
        self.refresh_ports()
        # è‡ªå‹•é¸ç¬¬ä¸€å€‹ï¼ˆè‹¥æœ‰ï¼‰
        if self.port_combo["values"]:
            self.port_combo.current(0)

        # è®“è¦–çª—å–å¾—ç„¦é»ï¼Œæ–¹å‘éµæ‰æœƒé€²ä¾†
        master.after(150, lambda: master.focus_force())

    def refresh_ports(self):
        items = list_serial_ports()
        display_list = [d for d, _ in items]
        self.port_map = {d: dev for d, dev in items}
        self.port_combo["values"] = display_list
        if not display_list:
            self.status_var.set("æ‰¾ä¸åˆ°å¯ç”¨é€£æ¥åŸ ï¼Œå¯æ‰‹å‹•è¼¸å…¥ï¼ˆå¦‚ COM7ï¼‰")
        else:
            self.status_var.set("è«‹é¸æ“‡é€£æ¥åŸ ä¸¦é»ã€é€£ç·šã€")

    def toggle_connect(self):
        if self.link.is_open():
            self.link.close()
            self.connect_btn.config(text="é€£ç·š")
            self.status_var.set("å·²æ–·ç·š")
            self.status.config(foreground="#A00")
            return

        # é€£ç·š
        sel = self.port_var.get().strip()
        if not sel:
            messagebox.showwarning("æç¤º", "è«‹å…ˆé¸æ“‡æˆ–è¼¸å…¥é€£æ¥åŸ ï¼ˆä¾‹å¦‚ COM7ï¼‰")
            return

        # è‹¥é¸çš„æ˜¯ä¸‹æ‹‰é¡¯ç¤ºå­—ä¸²ï¼Œè½‰å›å¯¦éš›è£ç½®åç¨±
        port = self.port_map.get(sel, sel)  # è‹¥æ²’å°æ‡‰ï¼Œè¦–ç‚ºä½¿ç”¨è€…æ‰‹å‹•è¼¸å…¥
        try:
            self.link.open(port, BAUD)
        except Exception as e:
            messagebox.showerror("é€£ç·šå¤±æ•—", f"ç„¡æ³•é–‹å•Ÿ {port}\n{e}")
            self.status_var.set("é€£ç·šå¤±æ•—")
            self.status.config(foreground="#A00")
            return

        self.connect_btn.config(text="æ–·ç·š")
        self.status_var.set(f"å·²é€£ç·šï¼š{port} @ {BAUD}")
        self.status.config(foreground="#0A0")

    # ===== éµç›¤äº‹ä»¶ =====
    def on_left(self, _):
        if not self.link.is_open(): return
        self.m1_angle -= STEP_DEG
        self.send_and_update(1, self.m1_angle)

    def on_right(self, _):
        if not self.link.is_open(): return
        self.m1_angle += STEP_DEG
        self.send_and_update(1, self.m1_angle)

    def on_up(self, _):
        if not self.link.is_open(): return
        self.m2_angle += STEP_DEG
        self.send_and_update(2, self.m2_angle)

    def on_down(self, _):
        if not self.link.is_open(): return
        self.m2_angle -= STEP_DEG
        self.send_and_update(2, self.m2_angle)

    def send_and_update(self, axis_id: int, angle: float):
        try:
            self.link.send_angle(axis_id, angle)
        except Exception as e:
            messagebox.showerror("å‚³é€å¤±æ•—", f"åºåˆ—å‚³é€å¤±æ•—ï¼Œå·²è‡ªå‹•æ–·ç·šã€‚\n{e}")
            self.connect_btn.config(text="é€£ç·š")
            self.status_var.set("å‚³é€å¤±æ•—ï¼Œå·²æ–·ç·š")
            self.status.config(foreground="#A00")
            return

        if axis_id == 1:
            self.lbl1.config(text=f"M1: {self.m1_angle:.3f}Â°")
        else:
            self.lbl2.config(text=f"M2: {self.m2_angle:.3f}Â°")

    def on_close(self):
        try:
            self.link.close()
        finally:
            self.master.destroy()

def main():
    root = tk.Tk()
    # Windows ç”¨è€…ï¼šè‹¥å­—é«”ç¼ºï¼Œæ”¹æˆ ("Consolas", 16) ä»¥å¤–çš„ç­‰å¯¬å­—é«”äº¦å¯
    app = ControllerApp(root)
    root.mainloop()

if __name__ == "__main__":
    main()

================================================================================
FILE: mega1_controller.py
================================================================================
# mega1_controller.py
# Mecanum Serial é™æ§å™¨ï¼ˆå¤šé€²ç¨‹ï¼›GUI ä¸é˜»å¡ï¼›è‡ªå‹•åˆ‡ MODEï¼›ç©©å®šç‰ˆï¼‰
# Run: python mega1_controller.py
# pip install pyserial

import time, sys, queue
import tkinter as tk
from tkinter import ttk, scrolledtext
import serial, serial.tools.list_ports

import multiprocessing as mp

# ====== åŸºæœ¬è¨­å®š ======
DEFAULT_BAUD   = 115200
SEND_INTERVAL  = 0.08   # å…ˆç”¨ 12.5Hzï¼Œç©©äº†å¯æ”¹å› 0.05
MODE_CHASSIS   = "CHASSIS"
MODE_SHOOTER   = "SHOOTER"

# ====== ä¸²åˆ—å­ç¨‹åº ======
def serial_worker(cmd_q: mp.Queue, log_q: mp.Queue):
    ser = None
    port = None; baud = None
    mode = MODE_CHASSIS
    vx = vy = wz = 0.0
    interval = SEND_INTERVAL
    pause_until = 0.0
    next_tx = 0.0
    buf = b""

    def log(txt): 
        try: log_q.put_nowait(txt)
        except queue.Full: pass

    def open_port(p, b):
        nonlocal ser, port, baud
        try:
            if ser: 
                try: ser.close()
                except: pass
            ser = serial.Serial(p, b, timeout=0, write_timeout=0)  # éé˜»å¡
            port, baud = p, b
            time.sleep(1.5)           # ç­‰ Arduino è‡ªå‹•é‡ç½®
            try: ser.reset_input_buffer()
            except: pass
            log(f"[OPEN] {p} @ {b}")
            # åŒæ­¥ç›®å‰æ¨¡å¼
            send_line(f"MODE {mode}")
        except Exception as e:
            ser = None; log(f"[ERROR] open failed: {e}")

    def close_port():
        nonlocal ser
        if ser:
            try: ser.close()
            except: pass
            ser = None
            log("[CLOSED] serial")

    def send_line(s):
        nonlocal pause_until
        if not ser: return
        try:
            if not s.endswith("\n"): s += "\n"
            ser.write(s.encode("ascii"))
            log(f"[SEND] {s.strip()}")
        except Exception as e:
            log(f"[ERROR] write: {e}")

    last_poll = 0.0
    while True:
        # 1) è™•ç†ä¾†è‡ª GUI çš„æŒ‡ä»¤
        drained = 0
        while drained < 50:
            try:
                msg = cmd_q.get_nowait()
            except queue.Empty:
                break

            t = msg.get("type")
            if t == "quit":
                close_port(); return
            elif t == "open":
                open_port(msg["port"], msg["baud"])
            elif t == "close":
                close_port()
            elif t == "set_interval":
                interval = max(0.01, float(msg["interval"]))
            elif t == "set_mode":
                mode = msg["mode"]
                send_line(f"MODE {mode}")
                pause_until = time.monotonic() + 0.2
            elif t == "velocity":
                vx, vy, wz = float(msg["vx"]), float(msg["vy"]), float(msg["wz"])
            elif t == "raw":
                send_line(msg["text"])
                pause = float(msg.get("pause_ms", 0)) / 1000.0
                if pause > 0: pause_until = time.monotonic() + pause
            drained += 1

        # 2) è®€å–åºåˆ—è¼¸å…¥ï¼ˆéé˜»å¡ï¼‰
        if ser:
            try:
                n = ser.in_waiting
                if n:
                    buf += ser.read(n)
                    while b"\n" in buf:
                        line, buf = buf.split(b"\n", 1)
                        try: text = line.decode("utf-8", "replace").rstrip("\r")
                        except: text = str(line)
                        log(text)
            except Exception as e:
                log(f"[ERROR] read: {e}")

        # 3) é€±æœŸæ€§å»£æ’­ vx,vy,wzï¼ˆåªåœ¨ CHASSIS ä¸”æœªæš«åœï¼‰
        now = time.monotonic()
        if ser and mode == MODE_CHASSIS and now >= next_tx and now >= pause_until:
            payload = f"{vx:.2f},{vy:.2f},{wz:.2f}\n"
            try:
                ser.write(payload.encode("ascii"))
            except Exception as e:
                log(f"[ERROR] write (bg): {e}")
            next_tx = now + interval

        # 4) å¾®ç¡é¿å…åƒæ»¿ CPU
        time.sleep(0.002)


# ====== GUI ä¸»ç¨‹åº ======
class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Mecanum Serial é™æ§å™¨ï¼ˆå¤šé€²ç¨‹ï¼›ä¸é˜»å¡ï¼‰")
        self.geometry("760x700"); self.resizable(False, False)

        # èˆ‡å­ç¨‹åºçš„ IPC ä½‡åˆ—
        self.cmd_q = mp.Queue(maxsize=500)
        self.log_q = mp.Queue(maxsize=1000)
        self.worker = None

        # ç‹€æ…‹
        self.mode_wanted = MODE_CHASSIS
        self.mode_current = None
        self.last_mode_change = 0.0
        self.speed_scale = tk.DoubleVar(value=0.6)
        self._moving_prev = False

        # éµç›¤æ——æ¨™
        self.k = {"w":False,"a":False,"s":False,"d":False,"left":False,"right":False,"up":False,"down":False}
        self.vx = self.vy = self.wz = 0.0

        # UI
        self._build_ui()
        self._bind_keys()

        # å®šæ™‚å™¨
        self.after(80,  self._pump_logs)
        self.after(50,  self._ui_tick)

        # é€Ÿåº¦èª¿æ•´é€£æŒ‰ç›¸é—œ
        self._speed_step = 0.05
        self._speed_repeat_job = None
        self._speed_repeat_dir = 0

    # --- UI ---
    def _build_ui(self):
        frm = ttk.Frame(self, padding=8); frm.pack(fill=tk.BOTH, expand=True)

        row=0
        ttk.Label(frm, text="Serial Portï¼š").grid(column=0,row=row,sticky=tk.W)
        self.port_var = tk.StringVar(value="")
        self.port_combo = ttk.Combobox(frm, width=20, textvariable=self.port_var, state="readonly")
        self._rescan_ports(); self.port_combo.grid(column=1,row=row,sticky=tk.W)
        ttk.Button(frm, text="é‡æ–°æƒæ", command=self._rescan_ports).grid(column=2,row=row,sticky=tk.W)

        row+=1
        ttk.Label(frm, text="Baud Rateï¼š").grid(column=0,row=row,sticky=tk.W)
        self.baud_var = tk.IntVar(value=DEFAULT_BAUD)
        ttk.Entry(frm, textvariable=self.baud_var, width=10).grid(column=1,row=row,sticky=tk.W)

        row+=1
        ttk.Label(frm, text="é€è¨Šé–“éš” (s)ï¼š").grid(column=0,row=row,sticky=tk.W)
        self.interval_var = tk.DoubleVar(value=SEND_INTERVAL)
        ttk.Entry(frm, textvariable=self.interval_var, width=8).grid(column=1,row=row,sticky=tk.W)
        ttk.Button(frm, text="å¥—ç”¨é–“éš”", command=self._apply_interval).grid(column=2,row=row,sticky=tk.W)

        row+=1
        ttk.Label(frm, text="é€Ÿåº¦å€ç‡ (Scale)ï¼š").grid(column=0,row=row,sticky=tk.W)
        ttk.Scale(frm, from_=0.0,to=1.0,variable=self.speed_scale,orient=tk.HORIZONTAL,length=320,
                  command=lambda v:self._on_scale()).grid(column=1,row=row,columnspan=2,sticky=tk.W)

        row+=1
        self.mode_lbl = ttk.Label(frm, text="æ§åˆ¶æ¨¡å¼ï¼šCHASSISï¼ˆè‡ªå‹•ï¼‰")
        self.mode_lbl.grid(column=0,row=row,columnspan=3,sticky=tk.W,pady=(6,6))

        row+=1
        ttk.Label(
            frm,
            text="æ“ä½œï¼šW/S å‰å¾Œ  A/D å·¦å³  â†/â†’ æ—‹è½‰  â†‘/â†“ èª¿é€Ÿ   F/R/S=æ­¥é€²   1/2/3=Servo 60/90/120   NEO=-100..100"
        ).grid(column=0,row=row,columnspan=3,sticky=tk.W)

        row+=1
        btn = ttk.Frame(frm); btn.grid(column=0,row=row,columnspan=3,sticky=tk.W,pady=(6,6))
        ttk.Button(btn, text="å•Ÿå‹•", command=self._start_worker).grid(column=0,row=0,padx=6)
        ttk.Button(btn, text="åœæ­¢", command=self._stop_worker).grid(column=1,row=0,padx=6)
        ttk.Button(btn, text="æ­¸é›¶(vx,vy,wz)", command=self._zero_motion).grid(column=2,row=0,padx=6)
        ttk.Button(btn, text="STATUS", command=lambda:self._send_raw("STATUS", pause_ms=400)).grid(column=3,row=0,padx=6)

        row+=1
        cur = ttk.LabelFrame(frm, text="ç›®å‰æ•¸å€¼ï¼ˆå·²ä¹˜é€Ÿåº¦å€ç‡ï¼‰"); cur.grid(column=0,row=row,columnspan=3,sticky=tk.EW)
        self.vx_lbl = ttk.Label(cur,text="vx: 0.00"); self.vx_lbl.grid(column=0,row=0,padx=8,pady=6,sticky=tk.W)
        self.vy_lbl = ttk.Label(cur,text="vy: 0.00"); self.vy_lbl.grid(column=1,row=0,padx=8,pady=6,sticky=tk.W)
        self.wz_lbl = ttk.Label(cur,text="wz: 0.00"); self.wz_lbl.grid(column=2,row=0,padx=8,pady=6,sticky=tk.W)
        self.sp_lbl = ttk.Label(cur,text=f"é€Ÿåº¦å€ç‡: {self.speed_scale.get():.2f}"); self.sp_lbl.grid(column=3,row=0,padx=8,pady=6,sticky=tk.W)

        row+=1
        stp = ttk.LabelFrame(frm, text="æ­¥é€²æ§åˆ¶"); stp.grid(column=0,row=row,columnspan=3,sticky=tk.W+tk.E)
        ttk.Button(stp,text="F",command=lambda:self._stepper("F")).grid(column=0,row=0,padx=6,pady=6)
        ttk.Button(stp,text="R",command=lambda:self._stepper("R")).grid(column=1,row=0,padx=6,pady=6)
        ttk.Button(stp,text="S(æŠ±æ­»)",command=lambda:self._stepper("S")).grid(column=2,row=0,padx=6,pady=6)
        ttk.Label(stp,text="ï¼ˆéµç›¤ F / R / X=åœï¼‰").grid(column=3,row=0,padx=8,pady=6,sticky=tk.W)

        row+=1
        # æ–°å¢ Servo æ§åˆ¶å€
        srv = ttk.LabelFrame(frm, text="Servoï¼ˆpin10ï¼šS1/S2/S3ï¼‰")
        srv.grid(column=0,row=row,columnspan=3,sticky=tk.W+tk.E)
        ttk.Button(srv, text="S1 (60Â°)",  command=lambda:self._servo_angle("S1")).grid(column=0,row=0,padx=6,pady=6)
        ttk.Button(srv, text="S2 (90Â°)",  command=lambda:self._servo_angle("S2")).grid(column=1,row=0,padx=6,pady=6)
        ttk.Button(srv, text="S3 (120Â°)", command=lambda:self._servo_angle("S3")).grid(column=2,row=0,padx=6,pady=6)
        ttk.Label(srv,text="ï¼ˆéµç›¤ 1 / 2 / 3ï¼‰").grid(column=3,row=0,padx=8,pady=6,sticky=tk.W)

        row+=1
        neo = ttk.LabelFrame(frm, text="NEO é€Ÿåº¦ï¼ˆ-100..100ï¼‰"); neo.grid(column=0,row=row,columnspan=3,sticky=tk.W+tk.E)
        self.neo_var = tk.StringVar(value="0")
        ttk.Entry(neo, textvariable=self.neo_var, width=8).grid(column=0,row=0,padx=(6,6),pady=6,sticky=tk.W)
        ttk.Button(neo,text="é€å‡º",command=self._send_neo).grid(column=1,row=0,padx=(0,6),pady=6,sticky=tk.W)
        ttk.Label(neo,text="ï¼ˆè¼¸å…¥å¾ŒæŒ‰ Enter ä¹Ÿå¯é€ï¼‰").grid(column=2,row=0,padx=6,pady=6,sticky=tk.W)

        row+=1
        self.info_lbl = ttk.Label(frm, text="ç‹€æ…‹ï¼šæœªé€£ç·š"); self.info_lbl.grid(column=0,row=row,sticky=tk.W)
        self.freq_lbl = ttk.Label(frm, text=f"é »ç‡: {1.0/self.interval_var.get():.1f} Hz"); self.freq_lbl.grid(column=1,row=row,sticky=tk.W,padx=12)

        row+=1
        lf = ttk.LabelFrame(frm, text="Serial Log (MEGA -> PC)"); lf.grid(column=0,row=row,columnspan=3,sticky=tk.NSEW,pady=(8,0))
        self.log = scrolledtext.ScrolledText(lf,height=12,width=88,state="disabled",wrap="none")
        self.log.pack(fill=tk.BOTH, expand=True, padx=4, pady=4)

        row+=1
        raw = ttk.LabelFrame(frm, text="Raw æŒ‡ä»¤ï¼ˆSTATUS / STOP / F / R / S / S1 / S2 / S3 / -100..100 / vx,vy,wz / MODE ...ï¼‰")
        raw.grid(column=0,row=row,columnspan=3,sticky=tk.EW,pady=(6,0))
        self.raw_var = tk.StringVar(value="STATUS")
        ttk.Entry(raw, textvariable=self.raw_var, width=56).grid(column=0,row=0,padx=(6,6))
        ttk.Button(raw, text="é€å‡º Raw", command=lambda:self._send_raw(self.raw_var.get())).grid(column=1,row=0)

        self.protocol("WM_DELETE_WINDOW", self._on_close)
        # Entry å…§æŒ‰ Enter é€ NEO
        self.bind_class("TEntry","<Return>", lambda e:self._send_neo())

    def _rescan_ports(self):
        ports = [p.device for p in serial.tools.list_ports.comports()] or ["(none)"]
        self.port_combo["values"] = ports
        if ports and ports[0] != "(none)":
            self.port_var.set(ports[0])

    def _apply_interval(self):
        val = max(0.01, float(self.interval_var.get()))
        self.interval_var.set(val)
        self.freq_lbl.config(text=f"é »ç‡: {1.0/val:.1f} Hz")
        self._send_cmd({"type":"set_interval","interval":val})

    # --- Worker æ§åˆ¶ ---
    def _start_worker(self):
        if self.worker and self.worker.is_alive():
            self._append("[INFO] å·²åœ¨åŸ·è¡Œ")
            return
        self.worker = mp.Process(target=serial_worker, args=(self.cmd_q, self.log_q), daemon=True)
        self.worker.start()
        self._append("[INFO] worker å•Ÿå‹•")
        # é–‹ port
        p = self.port_var.get().strip()
        if not p or p == "(none)":
            self._append("[WARN] è«‹å…ˆé¸æ“‡ Serial Port")
        else:
            self._send_cmd({"type":"open","port":p,"baud":int(self.baud_var.get())})
            self.info_lbl.config(text=f"ç‹€æ…‹ï¼šé€£ç·šä¸­ â†’ {p} @ {self.baud_var.get()}")
            # 1.8s å¾ŒåŒæ­¥æ¨¡å¼
            self.after(1800, lambda:self._ensure_mode(self.mode_wanted, force=True))

    def _stop_worker(self):
        self._send_cmd({"type":"close"})
        self.info_lbl.config(text="ç‹€æ…‹ï¼šæœªé€£ç·š")

    def _on_close(self):
        self._send_cmd({"type":"quit"})
        try:
            if self.worker: self.worker.join(timeout=0.2)
        except: pass
        self.destroy()

    def _send_cmd(self, msg):
        try: self.cmd_q.put_nowait(msg)
        except queue.Full: self._append("[WARN] cmd queue full")

    # --- å‹•ä½œï¼éµç›¤ ---
    def _bind_keys(self):
        def press(ev):
            k = ev.keysym.lower()
            # é€Ÿåº¦èª¿æ•´ï¼ˆâ†‘ / â†“ï¼‰
            if k == "up":
                self.k["up"] = True
                self._change_speed(self._speed_step)
                self._start_speed_repeat(+1)
                return
            if k == "down":
                self.k["down"] = True
                self._change_speed(-self._speed_step)
                self._start_speed_repeat(-1)
                return

            # æ­¥é€²å¿«æ·éµï¼ˆF/R/S=Xï¼‰
            if k == "f": self._stepper("F"); return
            if k == "r": self._stepper("R"); return
            if k == "x": self._stepper("S"); return

            # Servo å¿«æ·éµï¼ˆ1/2/3ï¼‰
            if k == "1": self._servo_angle("S1"); return
            if k == "2": self._servo_angle("S2"); return
            if k == "3": self._servo_angle("S3"); return

            # ç§»å‹•éµ
            if k in ("w","a","s","d","left","right"):
                self.k[k] = True
                self._update_motion_from_keys()

        def release(ev):
            k = ev.keysym.lower()
            if k in ("up","down"):
                self.k[k] = False
                self._stop_speed_repeat()
                return
            if k in ("w","a","s","d","left","right"):
                self.k[k] = False
                self._update_motion_from_keys()

        self.bind("<KeyPress>",  press)
        self.bind("<KeyRelease>", release)

        # NEO è¼¸å…¥æ¡†æŒ‰ Enter ç›´æ¥é€å‡º
        self.bind_class("TEntry", "<Return>", lambda e: self._send_neo())

        # é—œçª—
        self.protocol("WM_DELETE_WINDOW", self._on_close)

    # --- é€Ÿåº¦å€ç‡é€£æŒ‰ç”¨ ---
    def _change_speed(self, delta):
        v = float(self.speed_scale.get())
        v = max(0.0, min(1.0, v + delta))
        self.speed_scale.set(v)
        self.sp_lbl.config(text=f"é€Ÿåº¦å€ç‡: {v:.2f}")

    def _start_speed_repeat(self, direction):
        if self._speed_repeat_job is not None:
            return
        self._speed_repeat_dir = direction
        def _repeat():
            if (self._speed_repeat_dir > 0 and not self.k["up"]) or \
               (self._speed_repeat_dir < 0 and not self.k["down"]):
                self._speed_repeat_job = None
                return
            self._change_speed(self._speed_step * self._speed_repeat_dir)
            self._speed_repeat_job = self.after(120, _repeat)
        self._speed_repeat_job = self.after(400, _repeat)

    def _stop_speed_repeat(self):
        if self._speed_repeat_job is not None:
            self.after_cancel(self._speed_repeat_job)
            self._speed_repeat_job = None

    def _on_scale(self):
        self.sp_lbl.config(text=f"é€Ÿåº¦å€ç‡: {self.speed_scale.get():.2f}")

    def _update_motion_from_keys(self):
        vx = vy = wz = 0.0
        if self.k["w"] and not self.k["s"]: vx = 1.0
        elif self.k["s"] and not self.k["w"]: vx = -1.0
        if self.k["d"] and not self.k["a"]: vy = 1.0
        elif self.k["a"] and not self.k["d"]: vy = -1.0
        if self.k["left"] and not self.k["right"]: wz = -1.0
        elif self.k["right"] and not self.k["left"]: wz = 1.0

        moving = (vx!=0.0 or vy!=0.0 or wz!=0.0)
        self.vx, self.vy, self.wz = vx, vy, wz

        # å‚³çµ¦å­ç¨‹åºç•¶å‰é€Ÿåº¦ï¼ˆå­ç¨‹åºè‡ªè¡Œé€±æœŸå»£æ’­ï¼‰
        sp = float(self.speed_scale.get())
        self._send_cmd({"type":"velocity","vx":vx*sp,"vy":vy*sp,"wz":wz*sp})

        # ç”±ã€Œéœæ­¢â†’é–‹å§‹å‹•ã€é‚£ä¸€åˆ»åˆ‡åˆ° CHASSIS
        if moving and not self._moving_prev:
            self._ensure_mode(MODE_CHASSIS)
        self._moving_prev = moving

    def _zero_motion(self):
        self.vx = self.vy = self.wz = 0.0
        self._send_cmd({"type":"velocity","vx":0.0,"vy":0.0,"wz":0.0})

    def _ensure_mode(self, target, force=False):
        now = time.monotonic()
        if not force and self.mode_current == target: return
        if not force and (now - self.last_mode_change) < 0.35: return
        self.last_mode_change = now
        self.mode_wanted = target
        # æ¨‚è§€æ›´æ–° UIï¼Œä¸¦é€šçŸ¥å­ç¨‹åº
        self.mode_current = target
        self.mode_lbl.config(text=f"æ§åˆ¶æ¨¡å¼ï¼š{target}ï¼ˆè‡ªå‹•ï¼‰")
        self._send_cmd({"type":"set_mode","mode":target})

    # --- å‘½ä»¤ ---
    def _stepper(self, cmd):
        if cmd not in ("F","R","S"): return
        self._ensure_mode(MODE_SHOOTER)
        self._send_raw(cmd)

    def _servo_angle(self, cmd):
        # cmd: "S1"/"S2"/"S3"
        if cmd not in ("S1","S2","S3"):
            return
        self._ensure_mode(MODE_SHOOTER)
        self._send_raw(cmd)

    def _send_neo(self):
        s = self.neo_var.get().strip()
        try: v = int(s)
        except: 
            self._append("[WARN] NEO é€Ÿåº¦éœ€ç‚ºæ•´æ•¸ -100..100"); return
        v = max(-100, min(100, v))
        self._ensure_mode(MODE_SHOOTER)
        self._send_raw(str(v))

    def _send_raw(self, txt, pause_ms=0):
        up = txt.upper().strip()
        # F/R/S/S1/S2/S3 æˆ– ç´”æ•¸å­— â†’ SHOOTER
        if up in ("F","R","S","S1","S2","S3") or (txt.lstrip("-").isdigit() and up!="MODE"):
            self._ensure_mode(MODE_SHOOTER)
        elif "," in txt and not up.startswith("MODE "):
            # vx,vy,wz é¡ â†’ CHASSIS
            self._ensure_mode(MODE_CHASSIS)
        elif up.startswith("MODE "):
            tgt = up.split(None,1)[1].strip()
            if tgt in (MODE_CHASSIS, MODE_SHOOTER):
                self._ensure_mode(tgt, force=True)
        self._send_cmd({"type":"raw","text":txt,"pause_ms":pause_ms})

    # --- æ—¥èªŒ/ç•«é¢æ›´æ–° ---
    def _append(self, txt):
        self.log.configure(state="normal")
        self.log.insert(tk.END, txt + "\n")
        self.log.see(tk.END)
        self.log.configure(state="disabled")

    def _pump_logs(self):
        try:
            while True:
                line = self.log_q.get_nowait()
                self._append(line)
                if line.startswith("[OPEN]"):
                    self.info_lbl.config(text=line.replace("[OPEN]","ç‹€æ…‹ï¼šå·²é€£ç·š"))
                if line.startswith("[CLOSED]"):
                    self.info_lbl.config(text="ç‹€æ…‹ï¼šæœªé€£ç·š")
        except queue.Empty:
            pass
        self.after(80, self._pump_logs)

    def _ui_tick(self):
        sp = float(self.speed_scale.get())
        self.vx_lbl.config(text=f"vx: {self.vx*sp:.2f}")
        self.vy_lbl.config(text=f"vy: {self.vy*sp:.2f}")
        self.wz_lbl.config(text=f"wz: {self.wz*sp:.2f}")
        self.after(50, self._ui_tick)


if __name__ == "__main__":
    app = App()
    app.mainloop()

================================================================================
FILE: pi_detect.py
================================================================================
# conda activate tel_env
#python pi_detect.py
import cv2
import time
from ultralytics import YOLO

# ==========================================
#  å…¨åŸŸè®Šæ•¸è¨­å®š (User Configuration)
# ==========================================

# 1. æ¨¡å‹è·¯å¾‘ (å»ºè­°ä½¿ç”¨ .onnx ä»¥ç²å¾— Pi 5 æœ€ä½³æ•ˆèƒ½)
MODEL_PATH = "best.onnx"  # å¦‚æœè¦ç”¨ .ptï¼Œæ”¹ç‚º "best.pt"

# 2. è‡ªä¿¡åº¦é–¾å€¼ (0.0 ~ 1.0)
# ä½æ–¼æ­¤åˆ†æ•¸çš„ç‰©ä»¶ä¸æœƒè¢«è¦–ç‚ºåµæ¸¬æˆåŠŸ
CONF_THRESHOLD = 0.5

# 3. ç¯„åœå€åŸŸå¯¬åº¦ç™¾åˆ†æ¯” (0.1 ~ 0.9)
# è¨­å®š 0.3 ä»£è¡¨ç•«é¢ä¸­é–“ 30% ç‚ºã€Œç›®æ¨™å€åŸŸã€ï¼Œå·¦å³å…©å´æœƒæœ‰é‚Šç•Œç·š
ZONE_WIDTH_PERCENT = 0.3 

# 4. è¾¨è­˜å½±åƒå¹€ç‡ (ç›¸æ©Ÿè¨­å®š)
# è¨­å®šç›¸æ©Ÿå¸Œæœ›æ“·å–çš„ FPS (å¯¦éš› FPS ä»å–æ±ºæ–¼æ¨è«–é€Ÿåº¦)
TARGET_FPS = 5

# æ”å½±æ©Ÿè§£æåº¦è¨­å®š (è¶Šä½è¶Šå¿«ï¼Œå»ºè­° 640x480 æˆ– 320x240)
FRAME_WIDTH = 240
FRAME_HEIGHT = 180

# ==========================================
#  ä¸»ç¨‹å¼
# ==========================================

def main():
    # 1. è¼‰å…¥æ¨¡å‹
    print(f"æ­£åœ¨è¼‰å…¥æ¨¡å‹: {MODEL_PATH} ...")
    try:
        # task='detect' æœ‰åŠ©æ–¼åŠ é€Ÿè¼‰å…¥
        model = YOLO(MODEL_PATH, task='detect')
        print("æ¨¡å‹è¼‰å…¥æˆåŠŸï¼")
    except Exception as e:
        print(f"éŒ¯èª¤: ç„¡æ³•è¼‰å…¥æ¨¡å‹ã€‚è«‹ç¢ºèªæª”æ¡ˆæ˜¯å¦å­˜åœ¨ã€‚\n{e}")
        return

    # 2. åˆå§‹åŒ–æ”å½±æ©Ÿ
    cap = cv2.VideoCapture(0)
    
    # è¨­å®šç›¸æ©Ÿåƒæ•¸
    cap.set(cv2.CAP_PROP_FRAME_WIDTH, FRAME_WIDTH)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, FRAME_HEIGHT)
    cap.set(cv2.CAP_PROP_FPS, TARGET_FPS)

    if not cap.isOpened():
        print("éŒ¯èª¤: ç„¡æ³•é–‹å•Ÿæ”å½±æ©Ÿã€‚è«‹æª¢æŸ¥é€£æ¥ã€‚")
        return

    print(f"é–‹å§‹è¾¨è­˜... æŒ‰ 'q' éµé›¢é–‹")
    
    # ç”¨æ–¼è¨ˆç®—å¯¦éš› FPS
    prev_time = 0
    
    while True:
        success, frame = cap.read()
        if not success:
            print("ç„¡æ³•è®€å–å½±åƒå¹€")
            break

        # --- å€åŸŸè¨ˆç®—é‚è¼¯ ---
        # å–å¾—ç•«é¢ä¸­å¿ƒé» X åº§æ¨™
        center_x = FRAME_WIDTH // 2
        
        # è¨ˆç®—å·¦å³é‚Šç•Œçš„åƒç´ åç§»é‡ (ç¸½å¯¬åº¦ * ç™¾åˆ†æ¯” / 2)
        offset = int(FRAME_WIDTH * ZONE_WIDTH_PERCENT / 2)
        
        # å®šç¾©å·¦é‚Šç•Œèˆ‡å³é‚Šç•Œ X åº§æ¨™
        left_boundary = center_x - offset
        right_boundary = center_x + offset

        # --- 3. åŸ·è¡Œ AI æ¨è«– ---
        # verbose=False é—œé–‰çµ‚ç«¯æ©Ÿå¤§é‡è¼¸å‡ºï¼Œstream=True ç¯€çœè¨˜æ†¶é«”
        results = model.predict(frame, conf=CONF_THRESHOLD, verbose=False)

        # --- 4. ç¹ªåœ–èˆ‡è³‡æ–™è™•ç† ---
        # ç•«å‡º AI åµæ¸¬åˆ°çš„æ¡† (YOLO å…§å»ºç¹ªåœ–)
        # ç‚ºäº†ä¸è¦†è“‹æ‰æˆ‘å€‘è¦ç•«çš„ç·šï¼Œæˆ‘å€‘å…ˆæŠŠçµæœç•«ä¸Šå»ï¼Œå†ç•«ç·š
        annotated_frame = results[0].plot()

        # ç•«ä¸­å¿ƒå‚ç›´ç·š (é»ƒè‰², å¯¬åº¦ 2)
        cv2.line(annotated_frame, (center_x, 0), (center_x, FRAME_HEIGHT), (0, 255, 255), 2)

        # ç•«ç¯„åœå€åŸŸå·¦é‚Šç•Œ (ç¶ è‰², å¯¬åº¦ 2)
        cv2.line(annotated_frame, (left_boundary, 0), (left_boundary, FRAME_HEIGHT), (0, 255, 0), 2)

        # ç•«ç¯„åœå€åŸŸå³é‚Šç•Œ (ç¶ è‰², å¯¬åº¦ 2)
        cv2.line(annotated_frame, (right_boundary, 0), (right_boundary, FRAME_HEIGHT), (0, 255, 0), 2)

        # (é¸ç”¨) æ¨™ç¤ºæ–‡å­—
        cv2.putText(annotated_frame, "Target Zone", (left_boundary + 5, 20), 
                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 1)

        # --- è™•ç†åµæ¸¬åˆ°çš„ç‰©ä»¶ (ç¯„ä¾‹é‚è¼¯) ---
        # é€™è£¡ç¤ºç¯„å¦‚ä½•åˆ¤æ–·ç‰©ä»¶æ˜¯å¦åœ¨å€åŸŸå…§
        for box in results[0].boxes:
            # å–å¾—ç‰©ä»¶ä¸­å¿ƒé»
            x1, y1, x2, y2 = box.xyxy[0]
            obj_center_x = int((x1 + x2) / 2)
            obj_center_y = int((y1 + y2) / 2)

            # åˆ¤æ–·æ˜¯å¦åœ¨å€åŸŸå…§
            if left_boundary < obj_center_x < right_boundary:
                # å¦‚æœåœ¨å€åŸŸå…§ï¼Œç•«ä¸€å€‹å¯¦å¿ƒç´…é»åœ¨ç‰©ä»¶ä¸­å¿ƒ
                cv2.circle(annotated_frame, (obj_center_x, obj_center_y), 5, (0, 0, 255), -1)
                # ä½ å¯ä»¥åœ¨é€™è£¡åŠ å…¥ UART å‚³é€æŒ‡ä»¤ï¼Œä¾‹å¦‚ "Shoot" æˆ– "Grab"

        # --- è¨ˆç®—ä¸¦é¡¯ç¤ºå¯¦éš› FPS ---
        curr_time = time.time()
        fps = 1 / (curr_time - prev_time)
        prev_time = curr_time
        
        # é¡¯ç¤º FPS åœ¨å·¦ä¸Šè§’
        cv2.putText(annotated_frame, f"FPS: {fps:.1f}", (10, 30), 
                    cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)

        # --- 5. é¡¯ç¤ºç•«é¢ ---
        cv2.imshow("Pi 5 YOLO Detection", annotated_frame)

        # æŒ‰ 'q' é€€å‡º
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    # é‡‹æ”¾è³‡æº
    cap.release()
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()